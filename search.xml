<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[上汽通用五菱]]></title>
    <url>%2F%E4%B8%8A%E6%B1%BD%E9%80%9A%E7%94%A8%E4%BA%94%E8%8F%B1.html</url>
    <content type="text"><![CDATA[写在前面 上汽通用五菱现场跟其他现场程序主要区别在于`PlatABS`，及时记录每次更改。 程序路径在D:\BaiduNetdiskDownload\GX\Platforms2\PlatABS 柳州20191125在RBABS_SGMW增加齿讯学习 青岛印尼]]></content>
      <categories>
        <category>现场</category>
      </categories>
      <tags>
        <tag>上汽</tag>
        <tag>五菱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git command]]></title>
    <url>%2Fgit%20command.html</url>
    <content type="text"><![CDATA[写在前面 BashBash 常用命令 command 说明 cd 切换目录 pwd 查看当前目录 ls(ll) 查看当前目录文件 touch file.* 新建文件 rm file.* 删除文件 mkdir fold 新建文件夹 rm -r fold 删除文件夹 mv file destfold file 移动文件 clear 清屏 history 查看历史命令 git设置用户名与邮箱git config --global user.name &quot;Your Name&quot; git config --global user.email &quot;email@example.com&quot; command 说明 git init 在指定路径下执行，创建本地仓库 git config -l 查看git环境详细配置 git config –system –list 查看系统config git config –global –list 查看当前用户（global）配置 git config –local –list 查看当前仓库配置信息 git add 提交文件到暂存区，多个文件空格分开 git commit 提交到仓库分支 git commit -m “说明” 添加本次提交的说明便于查看更改记录 git log 历史版本信息 Git中版本用HEAD做标识，当前版本为HEAD，上一个版本是HEAD^ git reset –hard HEAD^ 退回到上个版本 git reset –hard commit_id HEAD 可用commit id前几位 git reflog 查看之前所有版本信息 git status 查看状态 git diff HEAD – file 查看工作区与版本库中的区别 git checkout – file 将工作区恢复到暂存区或版本库中的内容 git reset HEAD file 将暂存区恢复到版本库的内容 git rm file 删除文件 git remote add origin git@github.com:yourgithubname/Repositoryname.git 关联远程库 git push -u origin master 将本地仓库推送到远程仓库master分支并关联本地master分支 git push origin master 推送到远程master分支 git clone git@github.com:githubname/Repositoryname.git clone到本地 git branch bra 创建bra分支 git checkout bra 切换到bra分支 git checkout -b bra 等效于上面两条指令 git branch 查看分支，当前分支用*标识，切换分支后提交到当前分支 git checkout master 切换到master分支 git merge 合并指定分支到当前分支 git branch -d bra 删除bra分支 git switch -c bra 创建并切换分支 git switch master 切换到master分支]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IDMDownload]]></title>
    <url>%2FIDMDownload.html</url>
    <content type="text"><![CDATA[写在前面 Google Chrome 利用IDM下载器下载资源，可下载百度网盘资源 安装Google Chrome安装浏览器插件Tampermonkey安装百度网盘直接下载助手脚本安装IDM integration Module]]></content>
  </entry>
  <entry>
    <title><![CDATA[IBMMQ错误代码]]></title>
    <url>%2FIBMMQ%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81.html</url>
    <content type="text"><![CDATA[写在前面 IBM官方说明：https://www.ibm.com/support/knowledgecenter/SSFKSJ_9.0.0/com.ibm.mq.tro.doc/q040710_.htm ErrorCode Description 0 (0000) (RC0): MQRC_NONE 900 (0384) (RC900) MQRC_APPL_FIRST 999 (03E7) (RC999) MQRC_APPL_LAST 2001 (07D1) (RC2001) MQRC_ALIAS_BASE_Q_TYPE_ERROR 2002 (07D2) (RC2002) MQRC_ALREADY_CONNECTED 2003 (07D3) (RC2003) MQRC_BACKED_OUT 2004 (07D4) (RC2004) MQRC_BUFFER_ERROR 2005 (07D5) (RC2005) MQRC_BUFFER_LENGTH_ERROR 2006 (07D6) (RC2006) MQRC_CHAR_ATTR_LENGTH_ERROR 2007 (07D7) (RC2007) MQRC_CHAR_ATTRS_ERROR 2008 (07D8) (RC2008) MQRC_CHAR_ATTRS_TOO_SHORT 2009 (07D9) (RC2009) MQRC_CONNECTION_BROKEN 2010 (07DA) (RC2010) MQRC_DATA_LENGTH_ERROR 2011 (07DB) (RC2011) MQRC_DYNAMIC_Q_NAME_ERROR 2012 (07DC) (RC2012) MQRC_ENVIRONMENT_ERROR 2013 (07DD) (RC2013) MQRC_EXPIRY_ERROR 2014 (07DE) (RC2014) MQRC_FEEDBACK_ERROR 2016 (07E0) (RC2016) MQRC_GET_INHIBITED 2017 (07E1) (RC2017) MQRC_HANDLE_NOT_AVAILABLE 2018 (07E2) (RC2018) MQRC_HCONN_ERROR 2019 (07E3) (RC2019) MQRC_HOBJ_ERROR 2020 (07E4) (RC2020) MQRC_INHIBIT_VALUE_ERROR 2021 (07E5) (RC2021) MQRC_INT_ATTR_COUNT_ERROR 2022 (07E6) (RC2022) MQRC_INT_ATTR_COUNT_TOO_SMALL 2023 (07E7) (RC2023) MQRC_INT_ATTRS_ARRAY_ERROR 2024 (07E8) (RC2024) MQRC_SYNCPOINT_LIMIT_REACHED 2025 (07E9) (RC2025) MQRC_MAX_CONNS_LIMIT_REACHED 2026 (07EA) (RC2026) MQRC_MD_ERROR 2027 (07EB) (RC2027) MQRC_MISSING_REPLY_TO_Q 2029 (07ED) (RC2029) MQRC_MSG_TYPE_ERROR 2030 (07EE) (RC2030) MQRC_MSG_TOO_BIG_FOR_Q 2031 (07EF) (RC2031) MQRC_MSG_TOO_BIG_FOR_Q_MGR 2033 (07F1) (RC2033) MQRC_NO_MSG_AVAILABLE 2034 (07F2) (RC2034) MQRC_NO_MSG_UNDER_CURSOR 2035 (07F3) (RC2035) MQRC_NOT_AUTHORIZED 2036 (07F4) (RC2036) MQRC_NOT_OPEN_FOR_BROWSE 2037 (07F5) (RC2037) MQRC_NOT_OPEN_FOR_INPUT 2038 (07F6) (RC2038) MQRC_NOT_OPEN_FOR_INQUIRE 2039 (07F7) (RC2039) MQRC_NOT_OPEN_FOR_OUTPUT 2040 (07F8) (RC2040) MQRC_NOT_OPEN_FOR_SET 2041 (07F9) (RC2041) MQRC_OBJECT_CHANGED 2042 (07FA) (RC2042) MQRC_OBJECT_IN_USE 2043 (07FB) (RC2043) MQRC_OBJECT_TYPE_ERROR 2044 (07FC) (RC2044) MQRC_OD_ERROR 2045 (07FD) (RC2045) MQRC_OPTION_NOT_VALID_FOR_TYPE 2046 (07FE) (RC2046) MQRC_OPTIONS_ERROR 2047 (07FF) (RC2047) MQRC_PERSISTENCE_ERROR 2048 (0800) (RC2048) MQRC_PERSISTENT_NOT_ALLOWED 2049 (0801) (RC2049) MQRC_PRIORITY_EXCEEDS_MAXIMUM 2050 (0802) (RC2050) MQRC_PRIORITY_ERROR 2051 (0803) (RC2051) MQRC_PUT_INHIBITED 2052 (0804) (RC2052) MQRC_Q_DELETED 2053 (0805) (RC2053) MQRC_Q_FULL 2055 (0807) (RC2055) MQRC_Q_NOT_EMPTY 2056 (0808) (RC2056) MQRC_Q_SPACE_NOT_AVAILABLE 2057 (0809) (RC2057) MQRC_Q_TYPE_ERROR 2058 (080A) (RC2058) MQRC_Q_MGR_NAME_ERROR 2059 (080B) (RC2059) MQRC_Q_MGR_NOT_AVAILABLE 2061 (080D) (RC2061) MQRC_REPORT_OPTIONS_ERROR [z/OS]2062 (080E) (RC2062) MQRC_SECOND_MARK_NOT_ALLOWED 2063 (080F) (RC2063) MQRC_SECURITY_ERROR 2065 (0811) (RC2065) MQRC_SELECTOR_COUNT_ERROR 2066 (0812) (RC2066) MQRC_SELECTOR_LIMIT_EXCEEDED 2067 (0813) (RC2067) MQRC_SELECTOR_ERROR 2068 (0814) (RC2068) MQRC_SELECTOR_NOT_FOR_TYPE [z/OS][Windows]2069 (0815) (RC2069) MQRC_SIGNAL_OUTSTANDING [z/OS][Windows]2070 (0816) (RC2070) MQRC_SIGNAL_REQUEST_ACCEPTED 2071 (0817) (RC2071) MQRC_STORAGE_NOT_AVAILABLE 2072 (0818) (RC2072) MQRC_SYNCPOINT_NOT_AVAILABLE 2075 (081B) (RC2075) MQRC_TRIGGER_CONTROL_ERROR 2076 (081C) (RC2076) MQRC_TRIGGER_DEPTH_ERROR 2077 (081D) (RC2077) MQRC_TRIGGER_MSG_PRIORITY_ERR 2078 (081E) (RC2078) MQRC_TRIGGER_TYPE_ERROR 2079 (081F) (RC2079) MQRC_TRUNCATED_MSG_ACCEPTED 2080 (0820) (RC2080) MQRC_TRUNCATED_MSG_FAILED 2082 (0822) (RC2082) MQRC_UNKNOWN_ALIAS_BASE_Q 2085 (0825) (RC2085) MQRC_UNKNOWN_OBJECT_NAME 2086 (0826) (RC2086) MQRC_UNKNOWN_OBJECT_Q_MGR 2087 (0827) (RC2087) MQRC_UNKNOWN_REMOTE_Q_MGR 2090 (082A) (RC2090) MQRC_WAIT_INTERVAL_ERROR 2091 (082B) (RC2091) MQRC_XMIT_Q_TYPE_ERROR 2092 (082C) (RC2092) MQRC_XMIT_Q_USAGE_ERROR 2093 (082D) (RC2093) MQRC_NOT_OPEN_FOR_PASS_ALL 2094 (082E) (RC2094) MQRC_NOT_OPEN_FOR_PASS_IDENT 2095 (082F) (RC2095) MQRC_NOT_OPEN_FOR_SET_ALL 2096 (0830) (RC2096) MQRC_NOT_OPEN_FOR_SET_IDENT 2097 (0831) (RC2097) MQRC_CONTEXT_HANDLE_ERROR 2098 (0832) (RC2098) MQRC_CONTEXT_NOT_AVAILABLE [z/OS][Windows]2099 (0833) (RC2099) MQRC_SIGNAL1_ERROR 2100 (0834) (RC2100) MQRC_OBJECT_ALREADY_EXISTS 2101 (0835) (RC2101) MQRC_OBJECT_DAMAGED 2102 (0836) (RC2102) MQRC_RESOURCE_PROBLEM [UNIX, Linux, Windows, IBM i]2103 (0837) (RC2103) MQRC_ANOTHER_Q_MGR_CONNECTED 2104 (0838) (RC2104) MQRC_UNKNOWN_REPORT_OPTION [z/OS]2105 (0839) (RC2105) MQRC_STORAGE_CLASS_ERROR [z/OS]2106 (083A) (RC2106) MQRC_COD_NOT_VALID_FOR_XCF_Q 2107 (083B) (RC2107) MQRC_XWAIT_CANCELED [z/OS]2108 (083C) (RC2108) MQRC_XWAIT_ERROR 2109 (083D) (RC2109) MQRC_SUPPRESSED_BY_EXIT 2110 (083E) (RC2110) MQRC_FORMAT_ERROR 2111 (083F) (RC2111) MQRC_SOURCE_CCSID_ERROR 2112 (0840) (RC2112) MQRC_SOURCE_INTEGER_ENC_ERROR 2113 (0841) (RC2113) MQRC_SOURCE_DECIMAL_ENC_ERROR 2114 (0842) (RC2114) MQRC_SOURCE_FLOAT_ENC_ERROR 2115 (0843) (RC2115) MQRC_TARGET_CCSID_ERROR 2116 (0844) (RC2116) MQRC_TARGET_INTEGER_ENC_ERROR 2117 (0845) (RC2117) MQRC_TARGET_DECIMAL_ENC_ERROR 2118 (0846) (RC2118) MQRC_TARGET_FLOAT_ENC_ERROR 2119 (0847) (RC2119) MQRC_NOT_CONVERTED 2120 (0848) (RC2120) MQRC_CONVERTED_MSG_TOO_BIG [IBM i][UNIX][Windows]2121 (0849) (RC2121) MQRC_NO_EXTERNAL_PARTICIPANTS [IBM i][UNIX][Windows]2122 (084A) (RC2122) MQRC_PARTICIPANT_NOT_AVAILABLE [UNIX][Windows]2123 (084B) (RC2123) MQRC_OUTCOME_MIXED [UNIX][Windows][z/OS]2124 (084C) (RC2124) MQRC_OUTCOME_PENDING 2125 (084D) (RC2125) MQRC_BRIDGE_STARTED 2126 (084E) (RC2126) MQRC_BRIDGE_STOPPED [z/OS]2127 (084F) (RC2127) MQRC_ADAPTER_STORAGE_SHORTAGE [IBM i][UNIX][Windows]2128 (0850) (RC2128) MQRC_UOW_IN_PROGRESS [z/OS]2129 (0851) (RC2129) MQRC_ADAPTER_CONN_LOAD_ERROR [z/OS]2130 (0852) (RC2130) MQRC_ADAPTER_SERV_LOAD_ERROR [z/OS]2131 (0853) (RC2131) MQRC_ADAPTER_DEFS_ERROR [z/OS]2132 (0854) (RC2132) MQRC_ADAPTER_DEFS_LOAD_ERROR [z/OS]2133 (0855) (RC2133) MQRC_ADAPTER_CONV_LOAD_ERROR [IBM i][UNIX][Windows]2134 (0856) (RC2134) MQRC_BO_ERROR [IBM i][UNIX][Windows]2135 (0857) (RC2135) MQRC_DH_ERROR [IBM i][UNIX][Windows]2136 (0858) (RC2136) MQRC_MULTIPLE_REASONS [IBM i][UNIX][Windows]2137 (0859) (RC2137) MQRC_OPEN_FAILED [z/OS]2138 (085A) (RC2138) MQRC_ADAPTER_DISC_LOAD_ERROR [IBM i][UNIX][Windows]2139 (085B) (RC2139) MQRC_CNO_ERROR [z/OS]2140 (085C) (RC2140) MQRC_CICS_WAIT_FAILED 2141 (085D) (RC2141) MQRC_DLH_ERROR 2142 (085E) (RC2142) MQRC_HEADER_ERROR 2143 (085F) (RC2143) MQRC_SOURCE_LENGTH_ERROR 2144 (0860) (RC2144) MQRC_TARGET_LENGTH_ERROR 2145 (0861) (RC2145) MQRC_SOURCE_BUFFER_ERROR 2146 (0862) (RC2146) MQRC_TARGET_BUFFER_ERROR [Windows][V9.0.0.6 Mar 2019]2147 (0863) (RC2147) MQRC_INCOMPLETE_TRANSACTION 2148 (0864) (RC2148) MQRC_IIH_ERROR 2149 (0865) (RC2149) MQRC_PCF_ERROR 2150 (0866) (RC2150) MQRC_DBCS_ERROR [IBM i][UNIX][Windows]2152 (0868) (RC2152) MQRC_OBJECT_NAME_ERROR [IBM i][UNIX][Windows]2153 (0869) (RC2153) MQRC_OBJECT_Q_MGR_NAME_ERROR [IBM i][UNIX][Windows]2154 (086A) (RC2154) MQRC_RECS_PRESENT_ERROR [IBM i][UNIX][Windows]2155 (086B) (RC2155) MQRC_OBJECT_RECORDS_ERROR [IBM i][UNIX][Windows]2156 (086C) (RC2156) MQRC_RESPONSE_RECORDS_ERROR [z/OS]2157 (086D) (RC2157) MQRC_ASID_MISMATCH [IBM i][UNIX][Windows]2158 (086E) (RC2158) MQRC_PMO_RECORD_FLAGS_ERROR [IBM i][UNIX][Windows]2159 (086F) (RC2159) MQRC_PUT_MSG_RECORDS_ERROR [z/OS]2160 (0870) (RC2160) MQRC_CONN_ID_IN_USE 2161 (0871) (RC2161) MQRC_Q_MGR_QUIESCING 2162 (0872) (RC2162) MQRC_Q_MGR_STOPPING [z/OS]2163 (0873) (RC2163) MQRC_DUPLICATE_RECOV_COORD 2173 (087D) (RC2173) MQRC_PMO_ERROR 2182 (0886) (RC2182) MQRC_API_EXIT_NOT_FOUND 2183 (0887) (RC2183) MQRC_API_EXIT_LOAD_ERROR 2184 (0888) (RC2184) MQRC_REMOTE_Q_NAME_ERROR 2185 (0889) (RC2185) MQRC_INCONSISTENT_PERSISTENCE 2186 (088A) (RC2186) MQRC_GMO_ERROR [z/OS]2187 (088B) (RC2187) MQRC_CICS_BRIDGE_RESTRICTION 2188 (088C) (RC2188) MQRC_STOPPED_BY_CLUSTER_EXIT 2189 (088D) (RC2189) MQRC_CLUSTER_RESOLUTION_ERROR 2190 (088E) (RC2190) MQRC_CONVERTED_STRING_TOO_BIG [IBM i][UNIX][Windows]2191 (088F) (RC2191) MQRC_TMC_ERROR 2192 (0890) (RC2192) MQRC_PAGESET_FULL [z/OS]2192 (0890) (RC2192) MQRC_STORAGE_MEDIUM_FULL [z/OS]2193 (0891) (RC2193) MQRC_PAGESET_ERROR 2194 (0892) (RC2194) MQRC_NAME_NOT_VALID_FOR_TYPE 2195 (0893) (RC2195) MQRC_UNEXPECTED_ERROR 2196 (0894) (RC2196) MQRC_UNKNOWN_XMIT_Q 2197 (0895) (RC2197) MQRC_UNKNOWN_DEF_XMIT_Q 2198 (0896) (RC2198) MQRC_DEF_XMIT_Q_TYPE_ERROR 2199 (0897) (RC2199) MQRC_DEF_XMIT_Q_USAGE_ERROR [z/OS]2201 (0899) (RC2201) MQRC_NAME_IN_USE 2202 (089A) (RC2202) MQRC_CONNECTION_QUIESCING 2203 (089B) (RC2203) MQRC_CONNECTION_STOPPING [z/OS]2204 (089C) (RC2204) MQRC_ADAPTER_NOT_AVAILABLE 2206 (089E) (RC2206) MQRC_MSG_ID_ERROR 2207 (089F) (RC2207) MQRC_CORREL_ID_ERROR 2208 (08A0) (RC2208) MQRC_FILE_SYSTEM_ERROR 2209 (08A1) (RC2209) MQRC_NO_MSG_LOCKED 2210 (08A2) (RC2210) MQRC_SOAP_DOTNET_ERROR 2211 (08A3) (RC2211) MQRC_SOAP_AXIS_ERROR 2212 (08A4) (RC2212) MQRC_SOAP_URL_ERROR [z/OS]2217 (08A9) (RC2217) MQRC_CONNECTION_NOT_AUTHORIZED 2218 (08AA) (RC2218) MQRC_MSG_TOO_BIG_FOR_CHANNEL 2219 (08AB) (RC2219) MQRC_CALL_IN_PROGRESS 2220 (08AC) (RC2220) MQRC_RMH_ERROR 2222 (08AE) (RC2222) MQRC_Q_MGR_ACTIVE 2223 (08AF) (RC2223) MQRC_Q_MGR_NOT_ACTIVE 2224 (08B0) (RC2224) MQRC_Q_DEPTH_HIGH 2225 (08B1) (RC2225) MQRC_Q_DEPTH_LOW 2226 (08B2) (RC2226) MQRC_Q_SERVICE_INTERVAL_HIGH 2227 (08B3) (RC2227) MQRC_Q_SERVICE_INTERVAL_OK 2228 (08B4) (RC2228) MQRC_RFH_HEADER_FIELD_ERROR 2229 (08B5) (RC2229) MQRC_RAS_PROPERTY_ERROR 2232 (08B8) (RC2232) MQRC_UNIT_OF_WORK_NOT_STARTED [IBM i][UNIX][Windows]2233 (08B9) (RC2233) MQRC_CHANNEL_AUTO_DEF_OK [IBM i][UNIX][Windows]2234 (08BA) (RC2234) MQRC_CHANNEL_AUTO_DEF_ERROR [IBM i][UNIX][Windows]2235 (08BB) (RC2235) MQRC_CFH_ERROR [IBM i][UNIX][Windows]2236 (08BC) (RC2236) MQRC_CFIL_ERROR [IBM i][UNIX][Windows]2237 (08BD) (RC2237) MQRC_CFIN_ERROR [IBM i][UNIX][Windows]2238 (08BE) (RC2238) MQRC_CFSL_ERROR [IBM i][UNIX][Windows]2239 (08BF) (RC2239) MQRC_CFST_ERROR 2241 (08C1) (RC2241) MQRC_INCOMPLETE_GROUP 2242 (08C2) (RC2242) MQRC_INCOMPLETE_MSG [IBM i][UNIX][Windows]2243 (08C3) (RC2243) MQRC_INCONSISTENT_CCSIDS [IBM i][UNIX][Windows]2244 (08C4) (RC2244) MQRC_INCONSISTENT_ENCODINGS 2245 (08C5) (RC2245) MQRC_INCONSISTENT_UOW [IBM i][UNIX][Windows]2246 (08C6) (RC2246) MQRC_INVALID_MSG_UNDER_CURSOR 2247 (08C7) (RC2247) MQRC_MATCH_OPTIONS_ERROR 2248 (08C8) (RC2248) MQRC_MDE_ERROR 2249 (08C9) (RC2249) MQRC_MSG_FLAGS_ERROR 2250 (08CA) (RC2250) MQRC_MSG_SEQ_NUMBER_ERROR 2251 (08CB) (RC2251) MQRC_OFFSET_ERROR 2252 (08CC) (RC2252) MQRC_ORIGINAL_LENGTH_ERROR [IBM i][UNIX][Windows]2253 (08CD) (RC2253) MQRC_SEGMENT_LENGTH_ZERO [IBM i][UNIX][Windows]2255 (08CF) (RC2255) MQRC_UOW_NOT_AVAILABLE 2256 (08D0) (RC2256) MQRC_WRONG_GMO_VERSION 2257 (08D1) (RC2257) MQRC_WRONG_MD_VERSION [IBM i][UNIX][Windows]2258 (08D2) (RC2258) MQRC_GROUP_ID_ERROR [IBM i][UNIX][Windows]2259 (08D3) (RC2259) MQRC_INCONSISTENT_BROWSE 2260 (08D4) (RC2260) MQRC_XQH_ERROR [IBM i][UNIX][Windows]2261 (08D5) (RC2261) MQRC_SRC_ENV_ERROR [IBM i][UNIX][Windows]2262 (08D6) (RC2262) MQRC_SRC_NAME_ERROR [IBM i][UNIX][Linux]2263 (08D7) (RC2263) MQRC_DEST_ENV_ERROR [IBM i][UNIX][Windows]2264 (08D8) (RC2264) MQRC_DEST_NAME_ERROR 2265 (08D9) (RC2265) MQRC_TM_ERROR 2266 (08DA) (RC2266) MQRC_CLUSTER_EXIT_ERROR 2267 (08DB) (RC2267) MQRC_CLUSTER_EXIT_LOAD_ERROR 2268 (08DC) (RC2268) MQRC_CLUSTER_PUT_INHIBITED 2269 (08DD) (RC2269) MQRC_CLUSTER_RESOURCE_ERROR 2270 (08DE) (RC2270) MQRC_NO_DESTINATIONS_AVAILABLE [z/OS]2271 (08DF) (RC2271) MQRC_CONN_TAG_IN_USE 2272 (08E0) (RC2272) MQRC_PARTIALLY_CONVERTED 2273 (08E1) (RC2273) MQRC_CONNECTION_ERROR 2274 (08E2) (RC2274) MQRC_OPTION_ENVIRONMENT_ERROR [IBM i][UNIX][Windows]2277 (08E5) (RC2277) MQRC_CD_ERROR [IBM i][UNIX][Windows]2278 (08E6) (RC2278) MQRC_CLIENT_CONN_ERROR 2279 (08E7) (RC2279) MQRC_CHANNEL_STOPPED_BY_USER [UNIX, Linux, Windows, IBM i]2280 (08E8) (RC2280) MQRC_HCONFIG_ERROR [UNIX, Linux, Windows, IBM i]2281 (08E9) (RC2281) MQRC_FUNCTION_ERROR 2282 (08EA) (RC2282) MQRC_CHANNEL_STARTED 2283 (08EB) (RC2283) MQRC_CHANNEL_STOPPED 2284 (08EC) (RC2284) MQRC_CHANNEL_CONV_ERROR [UNIX, Linux, Windows, IBM i]2285 (08ED) (RC2285) MQRC_SERVICE_NOT_AVAILABLE [UNIX, Linux, Windows, IBM i]2286 (08EE) (RC2286) MQRC_INITIALIZATION_FAILED [UNIX, Linux, Windows, IBM i]2287 (08EF) (RC2287) MQRC_TERMINATION_FAILED [UNIX, Linux, Windows, IBM i]2288 (08F0) (RC2288) MQRC_UNKNOWN_Q_NAME [UNIX, Linux, Windows, IBM i]2289 (08F1) (RC2289) MQRC_SERVICE_ERROR [UNIX, Linux, Windows, IBM i]2290 (08F2) (RC2290) MQRC_Q_ALREADY_EXISTS [UNIX, Linux, Windows, IBM i]2291 (08F3) (RC2291) MQRC_USER_ID_NOT_AVAILABLE [UNIX, Linux, Windows, IBM i]2292 (08F4) (RC2292) MQRC_UNKNOWN_ENTITY [UNIX, Linux, Windows, IBM i]2294 (08F6) (RC2294) MQRC_UNKNOWN_REF_OBJECT 2295 (08F7) (RC2295) MQRC_CHANNEL_ACTIVATED 2296 (08F8) (RC2296) MQRC_CHANNEL_NOT_ACTIVATED 2297 (08F9) (RC2297) MQRC_UOW_CANCELED 2298 (08FA) (RC2298) MQRC_FUNCTION_NOT_SUPPORTED 2299 (08FB) (RC2299) MQRC_SELECTOR_TYPE_ERROR 2300 (08FC) (RC2300) MQRC_COMMAND_TYPE_ERROR 2301 (08FD) (RC2301) MQRC_MULTIPLE_INSTANCE_ERROR 2302 (08FE) (RC2302) MQRC_SYSTEM_ITEM_NOT_ALTERABLE 2303 (08FF) (RC2303) MQRC_BAG_CONVERSION_ERROR 2304 (0900) (RC2304) MQRC_SELECTOR_OUT_OF_RANGE 2305 (0901) (RC2305) MQRC_SELECTOR_NOT_UNIQUE 2306 (0902) (RC2306) MQRC_INDEX_NOT_PRESENT 2307 (0903) (RC2307) MQRC_STRING_ERROR 2308 (0904) (RC2308) MQRC_ENCODING_NOT_SUPPORTED 2309 (0905) (RC2309) MQRC_SELECTOR_NOT_PRESENT 2310 (0906) (RC2310) MQRC_OUT_SELECTOR_ERROR 2311 (0907) (RC2311) MQRC_STRING_TRUNCATED 2312 (0908) (RC2312) MQRC_SELECTOR_WRONG_TYPE 2313 (0909) (RC2313) MQRC_INCONSISTENT_ITEM_TYPE 2314 (090A) (RC2314) MQRC_INDEX_ERROR 2315 (090B) (RC2315) MQRC_SYSTEM_BAG_NOT_ALTERABLE 2316 (090C) (RC2316) MQRC_ITEM_COUNT_ERROR 2317 (090D) (RC2317) MQRC_FORMAT_NOT_SUPPORTED 2318 (090E) (RC2318) MQRC_SELECTOR_NOT_SUPPORTED 2319 (090F) (RC2319) MQRC_ITEM_VALUE_ERROR 2320 (0910) (RC2320) MQRC_HBAG_ERROR 2321 (0911) (RC2321) MQRC_PARAMETER_MISSING 2322 (0912) (RC2322) MQRC_CMD_SERVER_NOT_AVAILABLE 2323 (0913) (RC2323) MQRC_STRING_LENGTH_ERROR 2324 (0914) (RC2324) MQRC_INQUIRY_COMMAND_ERROR 2325 (0915) (RC2325) MQRC_NESTED_BAG_NOT_SUPPORTED 2326 (0916) (RC2326) MQRC_BAG_WRONG_TYPE 2327 (0917) (RC2327) MQRC_ITEM_TYPE_ERROR 2328 (0918) (RC2328) MQRC_SYSTEM_BAG_NOT_DELETABLE 2329 (0919) (RC2329) MQRC_SYSTEM_ITEM_NOT_DELETABLE 2330 (091A) (RC2330) MQRC_CODED_CHAR_SET_ID_ERROR 2331 (091B) (RC2331) MQRC_MSG_TOKEN_ERROR [z/OS]2332 (091C) (RC2332) MQRC_MISSING_WIH 2333 (091D) (RC2333) MQRC_WIH_ERROR 2334 (091E) (RC2334) MQRC_RFH_ERROR 2335 (091F) (RC2335) MQRC_RFH_STRING_ERROR 2336 (0920) (RC2336) MQRC_RFH_COMMAND_ERROR 2337 (0921) (RC2337) MQRC_RFH_PARM_ERROR 2338 (0922) (RC2338) MQRC_RFH_DUPLICATE_PARM 2339 (0923) (RC2339) MQRC_RFH_PARM_MISSING [z/OS]2340 (0924) (RC2340) MQRC_CHAR_CONVERSION_ERROR [z/OS]2341 (0925) (RC2341) MQRC_UCS2_CONVERSION_ERROR [z/OS]2342 (0926) (RC2342) MQRC_DB2_NOT_AVAILABLE [z/OS]2343 (0927) (RC2343) MQRC_OBJECT_NOT_UNIQUE [z/OS]2344 (0928) (RC2344) MQRC_CONN_TAG_NOT_RELEASED [z/OS]2345 (0929) (RC2345) MQRC_CF_NOT_AVAILABLE [z/OS]2346 (092A) (RC2346) MQRC_CF_STRUC_IN_USE [z/OS]2347 (092B) (RC2347) MQRC_CF_STRUC_LIST_HDR_IN_USE [z/OS]2348 (092C) (RC2348) MQRC_CF_STRUC_AUTH_FAILED [z/OS]2349 (092D) (RC2349) MQRC_CF_STRUC_ERROR [z/OS]2350 (092E) (RC2350) MQRC_CONN_TAG_NOT_USABLE [Windows][z/OS]2351 (092F) (RC2351) MQRC_GLOBAL_UOW_CONFLICT [Windows][z/OS]2352 (0930) (RC2352) MQRC_LOCAL_UOW_CONFLICT [Windows]2353 (0931) (RC2353) MQRC_HANDLE_IN_USE_FOR_UOW [HPNSS][Windows]2354 (0932) (RC2354) MQRC_UOW_ENLISTMENT_ERROR [HPNSS][Windows]2355 (0933) (RC2355) MQRC_UOW_MIX_NOT_SUPPORTED 2356 (0934) (RC2356) MQRC_WXP_ERROR 2357 (0935) (RC2357) MQRC_CURRENT_RECORD_ERROR 2358 (0936) (RC2358) MQRC_NEXT_OFFSET_ERROR 2359 (0937) (RC2359) MQRC_NO_RECORD_AVAILABLE [z/OS]2360 (0938) (RC2360) MQRC_OBJECT_LEVEL_INCOMPATIBLE 2361 (0939) (RC2361) MQRC_NEXT_RECORD_ERROR 2362 (093A) (RC2362) MQRC_BACKOUT_THRESHOLD_REACHED 2363 (093B) (RC2363) MQRC_MSG_NOT_MATCHED 2364 (093C) (RC2364) MQRC_JMS_FORMAT_ERROR [z/OS]2365 (093D) (RC2365) MQRC_SEGMENTS_NOT_SUPPORTED [z/OS]2366 (093E) (RC2366) MQRC_WRONG_CF_LEVEL 2367 (093F) (RC2367) MQRC_CONFIG_CREATE_OBJECT 2368 (0940) (RC2368) MQRC_CONFIG_CHANGE_OBJECT 2369 (0941) (RC2369) MQRC_CONFIG_DELETE_OBJECT 2370 (0942) (RC2370) MQRC_CONFIG_REFRESH_OBJECT 2371 (0943) (RC2371) MQRC_CHANNEL_SSL_ERROR [z/OS]2373 (0945) (RC2373) MQRC_CF_STRUC_FAILED [UNIX][Windows]2374 (0946) (RC2374) MQRC_API_EXIT_ERROR [UNIX][Windows]2375 (0947) (RC2375) MQRC_API_EXIT_INIT_ERROR [UNIX][Windows]2376 (0948) (RC2376) MQRC_API_EXIT_TERM_ERROR [UNIX][Windows]2377 (0949) (RC2377) MQRC_EXIT_REASON_ERROR [UNIX][Windows]2378 (094A) (RC2378) MQRC_RESERVED_VALUE_ERROR [UNIX, Linux, Windows, IBM i]2379 (094B) (RC2379) MQRC_NO_DATA_AVAILABLE [UNIX][Windows]2380 (094C) (RC2380) MQRC_SCO_ERROR [UNIX][Windows]2381 (094D) (RC2381) MQRC_KEY_REPOSITORY_ERROR [UNIX][Windows]2382 (094E) (RC2382) MQRC_CRYPTO_HARDWARE_ERROR [UNIX][Windows]2383 (094F) (RC2383) MQRC_AUTH_INFO_REC_COUNT_ERROR [UNIX][Windows]2384 (0950) (RC2384) MQRC_AUTH_INFO_REC_ERROR [UNIX][Windows]2385 (0951) (RC2385) MQRC_AIR_ERROR [UNIX][Windows]2386 (0952) (RC2386) MQRC_AUTH_INFO_TYPE_ERROR [UNIX][Windows]2387 (0953) (RC2387) MQRC_AUTH_INFO_CONN_NAME_ERROR [UNIX][Windows]2388 (0954) (RC2388) MQRC_LDAP_USER_NAME_ERROR [UNIX][Windows]2389 (0955) (RC2389) MQRC_LDAP_USER_NAME_LENGTH_ERR [UNIX][Windows]2390 (0956) (RC2390) MQRC_LDAP_PASSWORD_ERROR [UNIX][Windows]2391 (0957) (RC2391) MQRC_SSL_ALREADY_INITIALIZED [UNIX][Windows]2392 (0958) (RC2392) MQRC_SSL_CONFIG_ERROR [UNIX][Windows]2393 (0959) (RC2393) MQRC_SSL_INITIALIZATION_ERROR [z/OS]2394 (095A) (RC2394) MQRC_Q_INDEX_TYPE_ERROR [IBM i][UNIX][Windows]2395 (095B) (RC2395) MQRC_CFBS_ERROR 2396 (095C) (RC2396) MQRC_SSL_NOT_ALLOWED 2397 (095D) (RC2397) MQRC_JSSE_ERROR 2398 (095E) (RC2398) MQRC_SSL_PEER_NAME_MISMATCH 2399 (095F) (RC2399) MQRC_SSL_PEER_NAME_ERROR 2400 (0960) (RC2400) MQRC_UNSUPPORTED_CIPHER_SUITE 2401 (0961) (RC2401) MQRC_SSL_CERTIFICATE_REVOKED 2402 (0962) (RC2402) MQRC_SSL_CERT_STORE_ERROR 2406 (0966) (RC2406) MQRC_CLIENT_EXIT_LOAD_ERROR 2407 (0967) (RC2407) MQRC_CLIENT_EXIT_ERROR 2409 (0969) (RC2409) MQRC_SSL_KEY_RESET_ERROR 2411 (096B) (RC2411) MQRC_LOGGER_STATUS 2412 (096C) (RC2412) MQRC_COMMAND_MQSC 2413 (096D) (RC2413) MQRC_COMMAND_PCF 2414 (096E) (RC2414) MQRC_CFIF_ERROR 2415 (096F) (RC2415) MQRC_CFSF_ERROR 2416 (0970) (RC2416) MQRC_CFGR_ERROR 2417 (0971) (RC2417) MQRC_MSG_NOT_ALLOWED_IN_GROUP An explanation of the error, completion code, and programmer response. 2418 (0972) (RC2418) MQRC_FILTER_OPERATOR_ERROR 2419 (0973) (RC2419) MQRC_NESTED_SELECTOR_ERROR 2420 (0974) (RC2420) MQRC_EPH_ERROR 2421 (0975) (RC2421) MQRC_RFH_FORMAT_ERROR [IBM i][UNIX][Windows]2422 (0976) (RC2422) MQRC_CFBF_ERROR 2423 (0977) (RC2423) MQRC_CLIENT_CHANNEL_CONFLICT 2424 (0978) (RC2424) MQRC_SD_ERROR 2425 (0979) (RC2425) MQRC_TOPIC_STRING_ERROR 2426 (097A) (RC2426) MQRC_STS_ERROR 2428 (097C) (RC2428) MQRC_NO_SUBSCRIPTION 2429 (097D) (RC2429) MQRC_SUBSCRIPTION_IN_USE 2430 (097E) (RC2430) MQRC_STAT_TYPE_ERROR 2431 (097F) (RC2431) MQRC_SUB_USER_DATA_ERROR 2432 (0980) (RC2432) MQRC_SUB_ALREADY_EXISTS 2434 (0982) (RC2434) MQRC_IDENTITY_MISMATCH 2435 (0983) (RC2435) MQRC_ALTER_SUB_ERROR 2436 (0984) (RC2436) MQRC_DURABILITY_NOT_ALLOWED 2437 (0985) (RC2437) MQRC_NO_RETAINED_MSG 2438 (0986) (RC2438) MQRC_SRO_ERROR 2440 (0988) (RC2440) MQRC_SUB_NAME_ERROR 2441 (0989) (RC2441) MQRC_OBJECT_STRING_ERROR 2442 (098A) (RC2442) MQRC_PROPERTY_NAME_ERROR 2443 (098B) (RC2443) MQRC_SEGMENTATION_NOT_ALLOWED 2444 (098C) (RC2444) MQRC_CBD_ERROR 2445 (098D) (RC2445) MQRC_CTLO_ERROR 2446 (098E) (RC2446) MQRC_NO_CALLBACKS_ACTIVE 2448 (0990) (RC2448) MQRC_CALLBACK_NOT_REGISTERED 2449 (0991) (RC2449) MQRC_OPERATION_NOT_ALLOWED 2457 (0999) (RC2457) MQRC_OPTIONS_CHANGED 2458 (099A) (RC2458) MQRC_READ_AHEAD_MSGS 2459 (099B) (RC2459) MQRC_SELECTOR_SYNTAX_ERROR 2460 (099C) (RC2460) MQRC_HMSG_ERROR 2461 (099D) (RC2461) MQRC_CMHO_ERROR 2462 (099E) (RC2462) MQRC_DMHO_ERROR 2463 (099F) (RC2463) MQRC_SMPO_ERROR 2464 (09A0) (RC2464) MQRC_IMPO_ERROR 2465 (09A1) (RC2465) MQRC_PROPERTY_NAME_TOO_BIG 2466 (09A2) (RC2466) MQRC_PROP_VALUE_NOT_CONVERTED 2467 (09A3) (RC2467) MQRC_PROP_TYPE_NOT_SUPPORTED 2469 (09A5) (RC2469) MQRC_PROPERTY_VALUE_TOO_BIG 2470 (09A6) (RC2470) MQRC_PROP_CONV_NOT_SUPPORTED 2471 (09A7) (RC2471) MQRC_PROPERTY_NOT_AVAILABLE 2472 (09A8) (RC2472) MQRC_PROP_NUMBER_FORMAT_ERROR 2473 (09A9) (RC2473) MQRC_PROPERTY_TYPE_ERROR 2478 (09AE) (RC2478) MQRC_PROPERTIES_TOO_BIG 2479 (09AF) (RC2479) MQRC_PUT_NOT_RETAINED 2480 (09B0) (RC2480) MQRC_ALIAS_TARGTYPE_CHANGED 2481 (09B1) (RC2481) MQRC_DMPO_ERROR 2482 (09B2) (RC2482) MQRC_PD_ERROR 2483 (09B3) (RC2483) MQRC_CALLBACK_TYPE_ERROR 2484 (09B4) (RC2484) MQRC_CBD_OPTIONS_ERROR 2485 (09B5) (RC2485) MQRC_MAX_MSG_LENGTH_ERROR 2486 (09B6) (RC2486) MQRC_CALLBACK_ROUTINE_ERROR [z/OS]2487 (09B7) (RC2487) MQRC_CALLBACK_LINK_ERROR 2488 (09B8) (RC2488) MQRC_OPERATION_ERROR 2489 (09B9) (RC2489) MQRC_BMHO_ERROR 2490 (09BA) (RC2490) MQRC_UNSUPPORTED_PROPERTY 2492 (09BC) (RC2492) MQRC_PROP_NAME_NOT_CONVERTED 2494 (09BE) (RC2494) MQRC_GET_ENABLED 2495 (09BF) (RC2495) MQRC_MODULE_NOT_FOUND 2496 (09C0) (RC2496) MQRC_MODULE_INVALID 2497 (09C1) (RC2497) MQRC_MODULE_ENTRY_NOT_FOUND 2498 (09C2) (RC2498) MQRC_MIXED_CONTENT_NOT_ALLOWED 2499 (09C3) (RC2499) MQRC_MSG_HANDLE_IN_USE 2500 (09C4) (RC2500) MQRC_HCONN_ASYNC_ACTIVE 2501 (09C5) (RC2501) MQRC_MHBO_ERROR 2502 (09C6) (RC2502) MQRC_PUBLICATION_FAILURE 2503 (09C7) (RC2503) MQRC_SUB_INHIBITED 2504 (09C8) (RC2504) MQRC_SELECTOR_ALWAYS_FALSE 2507 (09CB) (RC2507) MQRC_XEPO_ERROR 2509 (09CD) (RC2509) MQRC_DURABILITY_NOT_ALTERABLE 2510 (09CE) (RC2510) MQRC_TOPIC_NOT_ALTERABLE 2512 (09D0) (RC2512) MQRC_SUBLEVEL_NOT_ALTERABLE 2513 (09D1) (RC2513) MQRC_PROPERTY_NAME_LENGTH_ERR 2514 (09D2) (RC2514) MQRC_DUPLICATE_GROUP_SUB 2515 (09D3) (RC2515) MQRC_GROUPING_NOT_ALTERABLE 2516 (09D4) (RC2516) MQRC_SELECTOR_INVALID_FOR_TYPE 2517 (09D5) (RC2517) MQRC_HOBJ_QUIESCED 2518 (09D6) (RC2518) MQRC_HOBJ_QUIESCED_NO_MSGS 2519 (09D7) (RC2519) MQRC_SELECTION_STRING_ERROR 2520 (09D8) (RC2520) MQRC_RES_OBJECT_STRING_ERROR 2521 (09D9) (RC2521) MQRC_CONNECTION_SUSPENDED 2522 (09DA) (RC2522) MQRC_INVALID_DESTINATION 2523 (09DB) (RC2523) MQRC_INVALID_SUBSCRIPTION 2524 (09DC) (RC2524) MQRC_SELECTOR_NOT_ALTERABLE 2525 (09DD) (RC2525) MQRC_RETAINED_MSG_Q_ERROR 2526 (09DE) (RC2526) MQRC_RETAINED_NOT_DELIVERED 2527 (09DF) (RC2527) MQRC_RFH_RESTRICTED_FORMAT_ERR 2528 (09E0) (RC2528) MQRC_CONNECTION_STOPPED 2529 (09E1) (RC2529) MQRC_ASYNC_UOW_CONFLICT 2530 (09E2) (RC2530) MQRC_ASYNC_XA_CONFLICT 2531 (09E3) (RC2531) MQRC_PUBSUB_INHIBITED 2532 (09E4) (RC2532) MQRC_MSG_HANDLE_COPY_FAILURE 2533 (09E5) (RC2533) MQRC_DEST_CLASS_NOT_ALTERABLE 2534 (09E6) (RC2534) MQRC_OPERATION_NOT_ALLOWED 2535 (09E7) MQRC_ACTION_ERROR 2537 (09E9) (RC2537) MQRC_CHANNEL_NOT_AVAILABLE 2538 (09EA) (RC2538) MQRC_HOST_NOT_AVAILABLE 2539 (09EB) (RC2539) MQRC_CHANNEL_CONFIG_ERROR 2540 (09EC) (RC2540) MQRC_UNKNOWN_CHANNEL_NAME 2541 (09ED) (RC2541) MQRC_LOOPING_PUBLICATION 2543 (09EF) (RC2543) MQRC_STANDBY_Q_MGR 2544 (09F0) (RC2544) MQRC_RECONNECTING 2545 (09F1) (RC2545) MQRC_RECONNECTED 2546 (09F2) (RC2546) MQRC_RECONNECT_QMID_MISMATCH 2547 (09F3) (RC2547) MQRC_RECONNECT_INCOMPATIBLE 2548 (09F4) (RC2548) MQRC_RECONNECT_FAILED 2549 (09F5) (RC2549) MQRC_CALL_INTERRUPTED 2550 (09F6) (RC2550) MQRC_NO_SUBS_MATCHED 2551 (09F7) (RC2551) MQRC_SELECTION_NOT_AVAILABLE 2552 (09F8) (RC2552) MQRC_CHANNEL_SSL_WARNING 2553 (09F9) (RC2553) MQRC_OCSP_URL_ERROR 2554 (09FA) (RC2554) MQRC_CONTENT_ERROR 2555 (09FB) (RC2555) MQRC_RECONNECT_Q_MGR_REQD 2556 (09FC) (RC2556) MQRC_RECONNECT_TIMED_OUT [UNIX, Linux, Windows, IBM i]2557 (09FD) (RC2557) MQRC_PUBLISH_EXIT_ERROR 2558 (09FE) (RC2558) MQRC_COMMINFO_ERROR 2560 (0A00) (RC2560) MQRC_MULTICAST_ONLY [z/OS]2561 (0A01) (RC2561) MQRC_DATA_SET_NOT_AVAILABLE 2562 (0A02) (RC2562) MQRC_GROUPING_NOT_ALLOWED 2563 (0A03) (RC2563) MQRC_GROUP_ADDRESS_ERROR 2564 (0A04) (RC2564) MQRC_MULTICAST_CONFIG_ERROR 2565 (0A05) (RC2565) MQRC_MULTICAST_INTERFACE_ERROR 2566 (0A06) (RC2566) MQRC_MULTICAST_SEND_ERROR 2567 (0A07) (RC2567) MQRC_MULTICAST_INTERNAL_ERROR 2568 (0A08) (RC2568) MQRC_CONNECTION_NOT_AVAILABLE 2569 (0A09) (RC2569) MQRC_SYNCPOINT_NOT_ALLOWED 2577 (0A11) (RC2577) MQRC_CHANNEL_BLOCKED 2578 (0A12) (RC2578) MQRC_CHANNEL_BLOCKED_WARNING 2583 (0A17) (RC2583) MQRC_INSTALLATION_MISMATCH 2587 (0A1B) (RC2587) MQRC_HMSG_NOT_AVAILABLE 2589 (0A1D) (RC2589) MQRC_INSTALLATION_MISSING 2590 (0A1E) (RC2590) MQRC_FASTPATH_NOT_AVAILABLE 2591 (0A1F) (RC2591) MQRC_CIPHER_SPEC_NOT_SUITE_B 2592 (0A20) (RC2592) MQRC_SUITE_B_ERROR 2593 (0A21)(RC2593) MQRC_CERT_VAL_POLICY_ERROR 2594 (0A22)(RC2594) MQRC_PASSWORD_PROTECTION_ERROR 2595 (0A23)(RC2595) MQRC_CSP_ERROR 2596 (0A24)(RC2596) MQRC_CERT_LABEL_NOT_ALLOWED 2598 (0A26)(RC2598) MQRC_ADMIN_TOPIC_STRING_ERROR 6100 (17D4) (RC6100) MQRC_REOPEN_EXCL_INPUT_ERROR 6101 (17D5) (RC6101) MQRC_REOPEN_INQUIRE_ERROR 6102 (17D6) (RC6102) MQRC_REOPEN_SAVED_CONTEXT_ERR 6103 (17D7) (RC6103) MQRC_REOPEN_TEMPORARY_Q_ERROR 6104 (17D8) (RC6104) MQRC_ATTRIBUTE_LOCKED 6105 (17D9) (RC6105) MQRC_CURSOR_NOT_VALID 6106 (17DA) (RC6106) MQRC_ENCODING_ERROR 6107 (17DB) (RC6107) MQRC_STRUC_ID_ERROR 6108 (17DC) (RC6108) MQRC_NULL_POINTER 6109 (17DD) (RC6109) MQRC_NO_CONNECTION_REFERENCE 6110 (17DE) (RC6110) MQRC_NO_BUFFER 6111 (17DF) (RC6111) MQRC_BINARY_DATA_LENGTH_ERROR 6112 (17E0) (RC6112) MQRC_BUFFER_NOT_AUTOMATIC 6113 (17E1) (RC6113) MQRC_INSUFFICIENT_BUFFER 6114 (17E2) (RC6114) MQRC_INSUFFICIENT_DATA 6115 (17E3) (RC6115) MQRC_DATA_TRUNCATED 6116 (17E4) (RC6116) MQRC_ZERO_LENGTH 6117 (17E5) (RC6117) MQRC_NEGATIVE_LENGTH 6118 (17E6) (RC6118) MQRC_NEGATIVE_OFFSET 6119 (17E7) (RC6119) MQRC_INCONSISTENT_FORMAT 6120 (17E8) (RC6120) MQRC_INCONSISTENT_OBJECT_STATE 6121 (17E9) (RC6121) MQRC_CONTEXT_OBJECT_NOT_VALID 6122 (17EA) (RC6122) MQRC_CONTEXT_OPEN_ERROR 6123 (17EB) (RC6123) MQRC_STRUC_LENGTH_ERROR 6124 (17EC) (RC6124) MQRC_NOT_CONNECTED 6125 (17ED) (RC6125) MQRC_NOT_OPEN 6126 (17EE) (RC6126) MQRC_DISTRIBUTION_LIST_EMPTY 6127 (17EF) (RC6127) MQRC_INCONSISTENT_OPEN_OPTIONS 6128 (17FO) (RC6128) MQRC_WRONG_VERSION 6129 (17F1) (RC6129) MQRC_REFERENCE_ERROR]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>IBMMQ</tag>
        <tag>ErrorCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现场工作代码路径说明]]></title>
    <url>%2F%E7%8E%B0%E5%9C%BA%E5%B7%A5%E4%BD%9C%E4%BB%A3%E7%A0%81%E8%B7%AF%E5%BE%84%E8%AF%B4%E6%98%8E.html</url>
    <content type="text"><![CDATA[写在前面 程序版本更新后可能没有合入原有程序，本文作为各现场的程序在电脑中存放的路径进行说明 国六排放MES联网D:\BaiduNetdiskDownload\GX\Platforms2\PlatABS 包含上汽临港、上汽南京、上汽宁德、上汽郑州、上汽无锡大通、长沙菲亚特、杭州福特(包含QLS，双怠速转速控制)、重庆福特、哈尔滨福特(继承杭州福特未测试) 上汽上汽检测线上汽DSA：D:\工作\software\Platforms_Using\Platforms2\SocketOpraLib 其中包括上汽郑州FAS、360；上汽宁德现场程序。 五菱五菱ABS：D:\工作\software\Platforms_Using\PlatABS\RBABS_SGMW 20191028新增宝骏现场更改保持在线3E 00为3E 80备份，目前调试未成功，采用备份程序 程序包含所有五菱现场最新的ABS程序 东风东风小康东风小康MES：D:\工作\现场工作文件整理\东风小康\319015-201905\Platforms2-正在使用\SpeciallNeed 程序为东风小康现场最新MES程序，新增64字节车型识别 东风乘用车(武汉)D:\工作\现场工作文件整理\武汉东风乘用车\Platforms2-武汉东风乘用车 其中SpecialNeed中包含FAS工位AEB相关提示，CanCmdOpraLib包含FAS相关安全算法ABS：D:\BaiduNetdiskDownload\GX\Platforms2\PlatABS\RBABS_DF 合众D:\BaiduNetdiskDownload\GX\Platforms2\PlatABS201909新增EP30ESC 比亚迪D:\BaiduNetdiskDownload\GX\Platforms2\Platforms2\CanCmdOpraLib201904增加联电供应商的转速控制 程序合并进行中PlatABS最新程序在D:\BaiduNetdiskDownload\GX\Platforms2\PlatABS中 20191120将五菱ABS更新至本工程代码中，待测试，其中包含齿讯学习 ABS合众东风乘用车 国六 现场 功能 上汽临港 MES 上汽名爵 MES 上汽宁德 MES 上汽郑州一期 MES 上汽无锡大通 MES、车型信息获取、ZTS匹配 福特杭州 MES、QLS、双怠速转速控制 福特重庆 MES、QLS、双怠速转速控制 福特哈尔滨 MES、QLS、双怠速转速控制 菲亚特长沙 MES 其他北汽莱西FAS]]></content>
      <categories>
        <category>工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ETP指令说明]]></title>
    <url>%2FETP%E6%8C%87%E4%BB%A4%E8%AF%B4%E6%98%8E.html</url>
    <content type="text"><![CDATA[写在前面 &emsp; 国六排放测试过程中常用通讯指令说明 详细资料请参考ISO15031-5或J1979-DA ISO15031-515765-4Service 01请求当前动力系统诊断数据01后最多可以读取6个PID(Parameter Identification)请求：01 PID PID PID PID PID PID回复：41 PID Data PID Data PID Data PID Data PID Data PID Data PID PID 说明 数据长度（byte） 计算 00 查看支持的PID 01 清除故障诊断码后的监视器状态 4 04 负载值 1 y=x/255 05 冷却液温度 1 y=x-40 0B 进气歧管绝对压力 1 y=x 0C 发动机转速 2 y=x/4 0D 车速 1 y=x 10 空气流量 2 y=x/100 11 节气门位置 1 y=x/255 44 Commanded Equivalence Ratio 2 y=2x/65535 5C 油温 1 y=x-40 6A 6E 78 尾气温度 7A 83 NOx传感器 85 NOx控制系统 PID 00请求：01 00回复： 41 00 A B C D //PID 01~2041 20 A B C D //PID 21~4041 40 A B C D //PID 41~6041 60 A B C D //PID 61~8041 80 A B C D //PID 81~A041 A0 A B C D //PID A1~C041 C0 A B C D //PID C1~E041 E0 A B C D //PID E1~FF 41 00 A B C DData A bit7 ~ Data D bit0 表示是否支持PID 01~20 如：41 00 90 39 00 00Data A = 90 = 1001 0000bit7 = 1; bit4 = 1表示支持 PID 01、PID 04Data B = 39 = 0011 1001bit5 = bit4 = bit3 = bit0 = 1表示支持 PID 0B、PID 0C、PID 0D、PID 10 Service 09PID PID 说明 数据长度（byte） 计算 02 VIN 17 04 Cal.ID 06 Cal.CVN 08 IPT ISO27145Service 2222 F4 对应 ISO15031的01服务22 F8 对应 ISO15031的09服务]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>ISO15031-5</tag>
        <tag>15765-4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rabbit MQ]]></title>
    <url>%2FRabbit%20MQ.html</url>
    <content type="text"><![CDATA[写在前面 安装Erlang安装Rabbit MQ安装前需先安装Erlang语言环境安装包下载地址：链接：https://pan.baidu.com/s/14_Z6JUdvQfY8PGQ4NBb73A提取码：abtt Rabbit MQ服务端安装安装软件安装在C盘(第一次安装到D盘后进入命令行程序不能执行，有兴趣可以研究研究)安装包下载地址：链接：https://pan.baidu.com/s/1NbHfVoGyo_oVAXzaTnZuAw提取码：9am0 启用管理工具在服务程序中确保RabbitMQ服务已启用安装完成后打开所有程序中的RabbitMQ Command Prompt (sbin dir)输入命令：’rabbitmq-plugins enable rabbitmq_management’打开浏览器输入http://localhost:15672默认账号、密码均为guest C# Producer项目中需要引用RabbitMQ.Client.dll下载链接为：链接：https://pan.baidu.com/s/1aJ-8RVJnJWibeqtPcTn9hw提取码：9d8n此版本支持.Net4.0，全版本请自行下载下载地址：http://www.rabbitmq.com/releases/rabbitmq-dotnet-client/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445using RabbitMQ.Client;var factory = new ConnectionFactory();factory.HostName = "localhost";//RabbitMQ服务在本地运行127.0.0.1factory.UserName = "guest";//用户名factory.Password = "guest";//密码using (var connection = factory.CreateConnection())&#123; using (var channel = connection.CreateModel())//创建一个Channel &#123; try &#123; channel.QueueDeclarePassive(mqqueueString);//判断队列是否存在 &#125; catch (Exception e) &#123; Log(mqqueueString + "队列未创建!"); throw e; //return false; &#125; /*在创建队列的时候，只有RabbitMQ上该队列不存在，才会去创建。 消息是以二进制数组的形式传输的，所以如果消息是实体对象的话，需要序列化和然后转化为二进制数组。*/ IBasicProperties properties = channel.CreateBasicProperties(); properties.ContentType = "application/json"; properties.ContentEncoding = "UTF-8"; properties.Headers = new Dictionary&lt;string, object&gt;(); properties.Headers.Add("srcSystem", "EQP"); properties.Headers.Add("desSystem", "IMES"); properties.Headers.Add("msgType", "EQP_IMES_EM"); properties.Headers.Add("msgID", msgID); channel.ConfirmSelect(); channel.QueueDeclare(mqqueueString, true, false, false, null);//消息队列 var body = Encoding.UTF8.GetBytes(msgStr); channel.BasicPublish(mqExchange, mqRoutingKey, properties, body); //开始传递 if (channel.WaitForConfirms()) &#123; Log("数据发送成功"); return true; &#125; else &#123; Log("数据发送成功，但未收到确认消息"); return false; &#125; &#125;&#125; 发送成功后可登录网页在Queues中查看到上传的消息队列及内容 函数说明QueueDeclare转自https://blog.csdn.net/vbirdbest/article/details/78670550 1234queueDeclare(String queue, boolean durable, boolean exclusive, Map&lt;String, Object&gt; arguments); queue: 队列名称 durable： 是否持久化, 队列的声明默认是存放到内存中的，如果rabbitmq重启会丢失，如果想重启之后还存在就要使队列持久化，保存到Erlang自带的Mnesia数据库中，当rabbitmq重启之后会读取该数据库 exclusive：是否排外的，有两个作用，一：当连接关闭时connection.close()该队列是否会自动删除；二：该队列是否是私有的private，如果不是排外的，可以使用两个消费者都访问同一个队列，没有任何问题，如果是排外的，会对当前队列加锁，其他通道channel是不能访问的，如果强制访问会报异常：com.rabbitmq.client.ShutdownSignalException: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=405, reply-text=RESOURCE_LOCKED - cannot obtain exclusive access to locked queue ‘queue_name’ in vhost ‘/‘, class-id=50, method-id=20)一般等于true的话用于一个队列只能有一个消费者来消费的场景 autoDelete：是否自动删除，当最后一个消费者断开连接之后队列是否自动被删除，可以通过RabbitMQ Management，查看某个队列的消费者数量，当consumers = 0时队列就会自动删除 arguments：队列中的消息什么时候会自动被删除 Message TTL(x-message-ttl)：设置队列中的所有消息的生存周期(统一为整个队列的所有消息设置生命周期), 也可以在发布消息的时候单独为某个消息指定剩余生存时间,单位毫秒, 类似于redis中的ttl，生存时间到了，消息会被从队里中删除，注意是消息被删除，而不是队列被删除， 特性Features=TTL, 单独为某条消息设置过期时间AMQP.BasicProperties.Builder properties = new AMQP.BasicProperties().builder().expiration(“6000”);channel.basicPublish(EXCHANGE_NAME, “”, properties.build(), message.getBytes(“UTF-8”)); Auto Expire(x-expires): 当队列在指定的时间没有被访问(consume, basicGet, queueDeclare…)就会被删除,Features=Exp Max Length(x-max-length): 限定队列的消息的最大值长度，超过指定长度将会把最早的几条删除掉， 类似于mongodb中的固定集合，例如保存最新的100条消息, Feature=Lim Max Length Bytes(x-max-length-bytes): 限定队列最大占用的空间大小， 一般受限于内存、磁盘的大小, Features=Lim B Dead letter exchange(x-dead-letter-exchange)： 当队列消息长度大于最大长度、或者过期的等，将从队列中删除的消息推送到指定的交换机中去而不是丢弃掉,Features=DLX Dead letter routing key(x-dead-letter-routing-key)：将删除的消息推送到指定交换机的指定路由键的队列中去, Feature=DLK Maximum priority(x-max-priority)：优先级队列，声明队列时先定义最大优先级值(定义最大值一般不要太大)，在发布消息的时候指定该消息的优先级， 优先级更高（数值更大的）的消息先被消费, Lazy mode(x-queue-mode=lazy)： Lazy Queues: 先将消息保存到磁盘上，不放在内存中，当消费者开始消费的时候才加载到内存中 Master locator(x-queue-master-locator) basicPublish1234basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) String exchange – 交换机名称String routingKey – 路由关键字BasicProperties props – 消息的基本属性，例如路由头等byte[] body – 消息体 12345basicPublish(String exchange, String routingKey, boolean mandatory, BasicProperties props, byte[] body) boolean mandatory – 是否为强制性 123456basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body) boolean immediate – 消息是否立即发送出去 BasicProperties1234567891011121314151617public static class BasicProperties&#123; private String contentType; //上下文类型 private String contentEncoding; //编码集 private Map&lt;String,Object&gt; headers; //消息头 private Integer deliveryMode; //消息的投递模式 private Integer priority; //优先级 private String correlationId; // private String replyTo; // private String expiration; //过期时间 private String messageId; //消息编号 private Date timestamp; //发送消息时的时间戳 private String type; // 消息类型 private String userId; private String appId; private String clusterId;&#125; C# Consumer编写客户端链接RabbitMQ读取信息 123456789101112131415161718192021222324using RabbitMQ.Client;using RabbitMQ.Client.Events;var factory = new ConnectionFactory();factory.HostName = "localhost";factory.UserName = "guest";factory.Password = "guest";using (var connection = factory.CreateConnection())&#123; using (var channel = connection.CreateModel()) &#123; channel.QueueDeclare("hello", false, false, false, null); var consumer = new EventingBasicConsumer(channel); channel.BasicConsume("hello", false, consumer); consumer.Received += (model, ea) =&gt; &#123; var body = ea.Body; var message = Encoding.UTF8.GetString(body); Console.WriteLine("已接收： &#123;0&#125;", message); &#125;; Console.ReadLine(); &#125;&#125; 函数说明BasicConsume123456789101112131415161718192021222324String basicConsume(String queue, Consumer callback)String basicConsume(String queue, boolean autoAck, Consumer callback)String basicConsume(String queue, boolean autoAck, Map&lt;String, Object&gt; arguments, Consumer callback)String basicConsume(String queue, boolean autoAck, String consumerTag, Consumer callback)String basicConsume(String queue, boolean autoAck, String consumerTag, boolean noLocal, boolean exclusive, Map&lt;String, Object&gt; arguments, Consumer callback) queue 队列名autoAck 是否自动确认消息,true自动确认,false 不自动要手动调用,建立设置为falseconsumerTag 消费者标签，用来区分多个消费者noLocal 设置为true，表示 不能将同一个Conenction中生产者发送的消息传递给这个Connection中 的消费者exclusive 是否排他arguments 消费者的参数callback 消费者 DefaultConsumer建立使用，重写其中的方法]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Rabbit MQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IBM MQ]]></title>
    <url>%2FIBM%20MQ.html</url>
    <content type="text"><![CDATA[写在前面 文中代码部分参考 https://blog.csdn.net/java_sparrow/article/details/80626705 若只做客户端部分的设计不需要安装客户端 网上关于IBMMQ相关资源实在太少，感谢前人的努力，站在前人的肩膀实在上太舒服了 IBMMQ 软件安装设置安装安装包(WebSphereMQ8.0)已上传网盘，下载后直接安装即可。链接：https://pan.baidu.com/s/1P9Dz74tvf8_SExH0Dl0hHA提取码：0a87 服务端配置下文中未提到的部分默认参数即可 创建队列管理器 设置侦听端口 创建通道 创建队列 添加用户组将当前用户添加到IBMMQ管理组 其中对象名为下图所示安装IBMMQ后自动创建的组mqm 至此，IBMMQ环境设置完毕 C# 连接MQ准备已安装IBMMQ软件程序中引用：amqmdnet.dll库文件（IBMMQ客户端安装后生成）路径分别为：C:\Program Files\IBM\WebSphere MQ\bin\amqmdnet.dll程序中添加using IBM.WMQ;程序安装完成后可能缺少mqdc.dll文件，可下载后放在安装路径C:\Program Files\IBM\WebSphere MQ\bin64 下链接：https://pan.baidu.com/s/19XMuE1q46K1E3BfO8lPPIQ提取码：5qhq 免安装IBMMQ准备好amqmdnet.dll在程序中直接引用即可下载地址：链接：https://pan.baidu.com/s/1Qb4bdDpqXmyQO5_Jx4hmnA提取码：soua若缺少其他文件请自取：IBMMQ8.0安装路径Bin文件夹链接：https://pan.baidu.com/s/1vdg4J2I1-1qLcHh_hnfXBA提取码：kgi9 C#代码初始化方式一123456789static MQQueueManager qMgr;static int CCSID = 437;MQEnvironment.Hostname = "10.91.232.46";MQEnvironment.Channel = "CHANNEL1";MQEnvironment.Port = 8802;MQEnvironment.UserId = "user";MQEnvironment.Password = "Password";// 队列管理器qMgr = new MQQueueManager("LG_2IN1_QMGR"); 方式二12345678910static MQQueueManager qMgr;Hashtable queueProperties = new Hashtable();queueProperties[MQC.TRANSPORT_PROPERTY] = MQC.TRANSPORT_MQSERIES_MANAGED;queueProperties[MQC.HOST_NAME_PROPERTY] = "192.168.1.9";queueProperties[MQC.PORT_PROPERTY] = 8802;queueProperties[MQC.CHANNEL_PROPERTY] = "CHANNEL1";queueProperties[MQC.USER_ID_PROPERTY] = "user";queueProperties[MQC.PASSWORD_PROPERTY] = "Password";queueProperties[MQC.CCSID_PROPERTY] = "1381";qMgr = new MQQueueManager("LG_2IN1_QMGR", queueProperties); 发送数据123456789101112131415161718192021222324252627282930public static void sendMsg(String msgStr)&#123; int openOptions = MQC.MQOO_INPUT_AS_Q_DEF | MQC.MQOO_OUTPUT | MQC.MQOO_INQUIRE; MQQueue queue = null; try &#123; // 建立通道的连接 queue = qMgr.AccessQueue(queueString, openOptions, null, null, null); MQMessage msg = new MQMessage();// 要写入队列的消息 msg.Format = MQC.MQFMT_STRING; msg.CharacterSet = CCSID; msg.Encoding = CCSID; // msg.writeObject(msgStr); msg.WriteString(msgStr); //将消息写入消息对象中 MQPutMessageOptions pmo = new MQPutMessageOptions(); msg.Expiry = -1; // 设置消息用不过期 queue.Put(msg, pmo);// 将消息放入队列 &#125; catch (Exception e) &#123; XmlFO.LogOut("IBMMQ",e.ToString()); &#125; finally &#123; if (queue != null) &#123; try &#123; queue.Close(); // qMgr.disconnect(); XmlFO.LogOut("IBMMQ","写入的消息为：" + msgStr); &#125; catch (MQException e) &#123; XmlFO.LogOut("IBMMQ", e.ToString()); &#125; &#125; &#125;&#125; 读取数据1234567891011121314151617181920212223242526272829303132public static void getMsg()&#123; int openOptions = MQC.MQOO_INPUT_AS_Q_DEF | MQC.MQOO_OUTPUT | MQC.MQOO_INQUIRE; MQQueue queue = null; try &#123; queue = qMgr.accessQueue(queueString, openOptions, null, null, null); System.out.println("==========================="); System.out.println("该队列当前的深度为:" + queue.getCurrentDepth()); System.out.println("==========================="); int depth = queue.getCurrentDepth(); // 将队列的里的消息读出来 while (depth-- &gt; 0) &#123; MQMessage msg = new MQMessage();// 要读的队列的消息 MQGetMessageOptions gmo = new MQGetMessageOptions(); queue.get(msg, gmo); System.out.println("消息的大小为：" + msg.getDataLength()); System.out.println("消息的内容：" + msg.readStringOfByteLength(msg.getDataLength())); System.out.println("---------------------------"); &#125; &#125; catch (Exception e) &#123; XmlFO.LogOut("IBMMQ", e.ToString()); &#125; finally &#123; if (queue != null) &#123; try &#123; queue.close(); qMgr.disconnect(); &#125; catch (MQException e) &#123; XmlFO.LogOut("IBMMQ", e.ToString()); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>IBMMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库自动备份、删除数据]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E3%80%81%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE.html</url>
    <content type="text"><![CDATA[文中指令可在windows命令行中执行测试本文介绍的是实用简单的方式实现所需功能，所有功能均可写在上位机软件中自动实现，但不同现场很难通用通过脚本的形式实现简单易改 Postgresql数据库备份脚本12345echo offset PRJDB=LocalDBset FileName=%PRJDB%_%date:~0,4%_%date:~5,2%_%date:~8,2%.backupif not exist &quot;D:\BBK\DBbackup&quot; (md D:\BBK\DBbackup)D:/&quot;Program Files (x86)&quot;/PostgreSQL/9.5/bin/pg_dump.exe --host localhost --port 5432 --username &quot;postgres&quot; --no-password --format custom --verbose --file &quot;D:\BBK\DBbackup\%FileName%&quot; &quot;LocalDB&quot; 说明： 备份保存路径为D:\BBK\DBbackup命名为：LocalDB_年_月_日.backupD:/&quot;Program Files (x86)&quot;/PostgreSQL/9.5/bin/pg_dump.exe为Postgresql数据库程序所在路径 删除表中数据12// 删除一个月以前的数据D:/&quot;Program Files (x86)&quot;/PostgreSQL/9.5/bin/psql -h 127.0.0.1 -p 5432 -d LocalDB -U postgres --command &quot;delete from 侧滑表 where 测试时间 &lt; (now() - interval &apos;1 month&apos;)&quot; 说明： D:/&quot;Program Files (x86)&quot;/PostgreSQL/9.5/bin为Postgresql数据库程序所在文件夹 时间扩展年interval &#39;2 years&#39;interval &#39;2 year&#39;interval &#39;2 y&#39;interval &#39;2 Y&#39;interval &#39;2Y&#39; 月interval &#39;1 month&#39;interval &#39;one month&#39; 周interval &#39;3 week&#39; 说明：interval 可以不写 运行时会提示数据用户名密码windows系统可在%APPDATA%\postgresql\pgpass.conf中添加服务器信息，实现免密操作格式：地址:端口:数据库:用户名:密码如：127.0.0.1:5432:LocalDB:postgres:123参考：https://www.postgresql.org/docs/current/libpq-pgpass.html 自动运行将上述shell指令分别复制到文本文档中另存为 name.bat，然后创建任务计划自动调用；任务计划创建方法：windows运行compmgmt.msc 新建任务计划程序按提示操作即可 SQLServer数据库自动备份打开数据库，依次进入：管理——维护计划，根据维护计划向导操作即可 删除数据启动SQL Server Agent服务，在步骤中新建作业，类型选择transact-SQL，命令中输入：declare @tm datetimedelete from tablename where tm&gt;=dateadd(month,-6,getdate())//删除表中6个月之前的数据然后打开计划自定义执行周期 Access直接用脚本复制重命名，新建任务计划自动执行 123set PRJDB=LocalDBset FileName=%PRJDB%_%date:~0,4%_%date:~5,2%_%date:~8,2%.backupcopy D:\BBK\LocalDB.mdb D:\BBK\DBbackup\%FileName%&quot;]]></content>
      <categories>
        <category>工作</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Postgresql</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库链接字符串汇总]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[通用示例12345678910string ConnStr_EOLDDATA = "$System.Data.SqlClient$Data Source=.;Initial Catalog=EOLDATA;Persist Security Info=True;User ID=sa;Password=321";string SqlLoginTable = string.Format("select * from [登录表] where [VIN] = '&#123;0&#125;'", textBoxVIN.Text);DbDataAdapter AdapLogin = BConnString.CreateDataAdapter(SqlLoginTable, ConnStr_EOLDDATA);DataTable dtLogin = new DataTable();AdapLogin.Fill(dtLogin);DataRow drLogin = null;if (dtLogin.Rows.Count &lt; 1) drLogin = dtLogin.Rows.Add();else drLogin = dtLogin.Rows[0];//drLogin = dtLogin.Rows.Count &lt; 1 ? dtLogin.Rows.Add() : dtLogin.Rows[0]; Access链接字符串：$System.Data.OleDb$Provider=Microsoft.Jet.OLEDB.4.0;Data Source=LoginSet.mdbSQL字符串：select * from [Table] where ZTS = &#39;zts&#39; Postgresql链接字符串：$Npgsql$Database=LocalDB;Host=LocalHost;Port=5432;Username=postgres;Password=123SQL字符串：select * from [Table] where VIN=&#39;vin&#39; order by ID desc 判断字段中包含某字符串所在位select * from [车型库] where POSITION(&#39;{0}&#39; in [VIN])&gt;0eg:postion(&#39;abc&#39; in &#39;123abc123&#39;)—&gt;4 SQLServerSQLServer字符串：$System.Data.SqlClient$Data Source=EOLSERVICE;Initial Catalog=EOLData;Persist Security Info=True;User ID=sa;Password=321SQL字符串：select * from [Table] where VIN=&#39;vin&#39; order by ID desc 判断字段中包含某字符串所在位select * from [车型库] where charindex(&#39;{0}&#39;,[VIN])&gt;0 选择左侧为某字符串select * from [车型库] where left([VIN],3)=&#39;LZW&#39; Oracle不需要借助客户端可直接访问数据库string Ora_ConnStr = &quot;User ID=jcxuser;Password=jcxuser;Data Source =(DESCRIPTION = (ADDRESS_LIST =(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.111.89)(PORT = 1521))) (CONNECT_DATA = (SERVER = DEDICATED)(SERVICE_NAME = yadata)))&quot;; 需要安装Oracle客户端并配置链接方可访问string Ora_ConnStrOLEDB = &quot;Provider=OraOLEDB.Oracle;Data Source=yadata;Persist Security Info=True;Password=jcxuser;User ID=jcxuser&quot;;有时间对比这两种链接字符串的区别，下面可访问但访问数据不全string Ora_ConnStr = &quot;$System.Data.OleDb$Provider=MSDAORA;Data Source=yadata;Persist Security Info=True;Password=jcxuser;User ID=jcxuser&quot;; 1234567OracleConnection conn = new OracleConnection(Ora_ConnStr);conn.Open();string OracleSqlStr = string.Format("select * from &#123;0&#125; where SN = '&#123;1&#125;'", Ora_tableForVSN, sVIN);DataTable dtVSN = new DataTable();OracleDataAdapter odaVSN = new OracleDataAdapter(OracleSqlStr, Ora_ConnStr);odaVSN.Fill(dtVSN);conn.Close(); 123456789OleDbConnection conn = new OleDbConnection(Ora_ConnStrOLEDB);conn.Open();OleDbCommand cmdVSN = conn.CreateCommand();cmdVSN.CommandText = string.Format("select * from &#123;0&#125; where SN = '&#123;1&#125;'", Ora_tableForVSN, sVIN);DataTable dtVSN = new DataTable();OleDbDataAdapter odaVSN = new OleDbDataAdapter();odaVSN.SelectCommand = cmdVSN;odaVSN.Fill(dtVSN);conn.Close();]]></content>
      <categories>
        <category>工作</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>链接字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现场软件安装包下载]]></title>
    <url>%2F%E7%8E%B0%E5%9C%BA%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD.html</url>
    <content type="text"><![CDATA[百度网盘下载推荐用ENFI下载器链接：https://www.enfi.cloud/#/index 串口调试助手链接：https://pan.baidu.com/s/1KAisgybEesC8fMTwJ-oK3w提取码：au8d Socktools链接：https://pan.baidu.com/s/1lXWZWLjt9LE4xxCjK873-Q提取码：v5qn .NetFramework4.0链接：https://pan.baidu.com/s/1Hwdt4rEToEK4Ao4ljvmURA提取码：wlfc 虚拟串口链接：https://pan.baidu.com/s/1FrqtaKrp74EPmyvVqNOu6g提取码：wkv3 VisualStudio2010链接：https://pan.baidu.com/s/1Z-EUIWWsJmUN22KS8QNKcg提取码：rwpn SQLServer2008链接：https://pan.baidu.com/s/15hGavjba8ewaFxlyd_K-dw提取码：xdxa KepServer5.2链接：https://pan.baidu.com/s/1zmX5Myqts5zzG3DTjairdg提取码：7dwx Postgresql9.5.3链接：https://pan.baidu.com/s/1NA4aNTu9CGmAEYd9aeo-Gg提取码：l9h6 Setup_Npgsql-2.2.3.0-r2-net40链接：https://pan.baidu.com/s/1wLBTi8vgJUCvlqO8HvorOQ提取码：yv4h Orical 10g Client链接：https://pan.baidu.com/s/1btHhUl-ataDjq6J7KAWfuA提取码：ks71 psqlodbc_x86链接：https://pan.baidu.com/s/19FKNrVT4CxO5yHyvhVayOw提取码：9yud]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>安装包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[诊断指令说明--OBD模块]]></title>
    <url>%2F%E8%AF%8A%E6%96%AD%E6%8C%87%E4%BB%A4%E8%AF%B4%E6%98%8E--OBD%E6%A8%A1%E5%9D%97.html</url>
    <content type="text"><![CDATA[通讯测试串口测试车辆通讯问题SendID：0730；RecvID：073833 33 07 38 FF FF 88 88 设置滤波 只接收ID为0738的指令55 55 07 30 02 10 03 00 00 00 00 00 88 88 发送指令 发送ID为0730其中： 02 10 03 00 00 00 00 00 为CAN指令，第一位为长度位。为什么用55指令测试通讯： 55指令中不包含CAN通讯等待的时间参数，不会出现第三版协议因超时时间较短而导致收不到车辆回复。 第三版协议指令说明发送数据F0 F0XX XX// 数据长度XX //指令类型:&emsp;&emsp;10: CAN数据（针对ISO15765协议而定）&emsp;&emsp;13: 设置CAN通信滤波ID&emsp;&emsp;14: 只发送指定长度(小于等于8)CAN数据&emsp;&emsp;15:设置CAN通信波特率及标准帧拓展帧&emsp;&emsp;20 :K线数据&emsp;&emsp;25: 设置K线初始化波特率及通信波特率&emsp;&emsp;05: 设置超时时间 CAN通讯短等待回复时间，默认100ms，长等待时间，默认5000msXX XX XX XX //本机IDXX XX XX XX //目标IDXX n…//数据FF//结尾 接收数据0F 0FXX XX// 数据长度XX //指令类型:&emsp;&emsp;10: CAN数据（针对ISO15765协议而定）&emsp;&emsp;13: 设置CAN通信滤波ID&emsp;&emsp;14: 接收到已设置了CAN通信滤波ID的CAN数据&emsp;&emsp;15:设置CAN通信波特率及标准帧拓展帧&emsp;&emsp;20: K线数据&emsp;&emsp;25: 设置K线初始化波特率及通信波特率&emsp;&emsp;05: 设置通信响应超时时间成功的响应指令&emsp;&emsp;7F: 收到错误回复，比如超时、数据格式错误等XX XX XX XX //本机IDXX XX XX XX //目标IDXX n…//数据FF//结尾 示例：发送：F0 F0 00 0C 10 00 00 07 20 00 00 07 30 10 03 FF接收：0F 0F 00 10 10 00 00 07 20 00 00 07 30 50 03 00 32 01 F4 FF 设置指定滤波ID及读取超时时间(0x12)发送：F0 F0 00 07 12 00 00 07 30 14 FF接收：若CAN总线上指定滤波ID(00 00 07 20)对应的数据及超时时间（20*10=200ms），则返回：0F 0F 00 0E 12 00 00 07 30 00 01 02 03 04 05 06 07 FF //(00 00 07 30 目标ID)否则返回超时提示； 设置滤波ID(0x13)发送：F0 F0 00 0A 13 00 00 07 20 FF FF FF FF FF接收：若CAN总线上有设置的ID对应的数据，则返回：0F 0F 00 0E 14 00 00 07 30 50 03 00 32 01 F4 FF//(00 00 07 30 目标ID)否则无返回； 只发送单帧数据(0x14)发送：F0 F0 00 0E 14 00 00 07 20 00 00 00 00 12 34 56 78 FF发送的目标ID: 00 00 07 20 发送的CAN数据: 12 34 56 78 设置波特率及标准帧拓展帧（0x15）第6字节及第7字节表示设置波特率大小，单位kbps第8字节及第9字节表示设置标准帧或拓展帧：00 00 标准帧 00 01 拓展帧接收数据01代表设置成功，无返回或者返回其他字节数目则设置失败，请注意检测数据格式。比如发送：F0 F0 00 06 15 01 F4 00 01 FF//设置波特率500K，拓展帧接收：0F 0F 00 03 15 01 FF//设置成功 设置波特率及标准帧拓展帧，无返回确认指令（针对0x15）(0x16)第6字节及第7字节表示设置波特率大小，单位kbps第8字节及第9字节表示设置标准帧或拓展帧：00 00 标准帧 00 01 拓展帧设置成功与否，都不返回数据发送：F0 F0 00 06 16 01 F4 00 01 FF//设置波特率500K，拓展帧接收：无 K-Line设置初始波特率及正常通讯波特率（0x25）第6字节及第7字节表示设置初始波特率（单位：bps），默认200bps第8字节及第9字节表示设置正常通讯波特率（单位：bps），默认10400bps接收数据01代表设置成功，无返回或者返回其他字节数目则设置失败，请注意检测数据格式。 发送：F0 F0 00 06 25 00 C8 28 A0 FF//设置波初始波特率200bps及正常通讯波特率10400bps接收：0F 0F 00 03 25 01 FF//设置成功 K线指令（0x20）发送：F0 F0 00 08 20 80 28 F1 01 81 1b FF接收：0F 0F 00 0A 20 80 F1 28 03 C1 6B 8F 57 FF 通讯错误的回复指令（0x7F）0F 0F 00 03 7F XX FF 故障码说明 XX故障码(Hex) 说明 00 等待接收或延时发送 02 发送单帧100ms超时未收到CAN数据 03 5000ms超时提示 04 接收多帧时，未收到数据100ms超时提示 05 读取指定ID数据，超时提示 11 接收多帧时未收到流控帧提示 12 接收到的CAN数据长度大于7错误提示 13 接收到未符合要求的数据类型 21 发送Kline数据500ms超时未收到CAN数据 F2 接收到PC数据不是以0xFF结尾 F1 CAN数据超过4096个字节 2A K线初始化后未接收到”格式”字节 2B K线初始化后自反馈是未接收到指定长度K线数据 2C K线未接收到0x80字节]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>诊断指令</tag>
        <tag>CAN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作-BBK]]></title>
    <url>%2F%E5%B7%A5%E4%BD%9C-BBK.html</url>
    <content type="text"><![CDATA[现场软件备份路径 现场问题整理 现场软件安装包下载]]></content>
      <categories>
        <category>工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML常用标签]]></title>
    <url>%2FHTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE.html</url>
    <content type="text"><![CDATA[HTML标签HTML标题123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;h1&lt;/h1&gt; &lt;h2&gt;h2&lt;/h2&gt; &lt;h3&gt;h3&lt;/h3&gt; &lt;h4&gt;h4&lt;/h4&gt; &lt;h5&gt;h5&lt;/h5&gt; &lt;h6&gt;h6&lt;/h6&gt; &lt;/body&gt;&lt;/html&gt; 水平线/分割线&lt;hr/&gt; 注释html注释：&lt;!-- comment --&gt; 段落及换行html段落&lt;p&gt;以及段落换行&lt;br/&gt; 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;hello world&lt;/p&gt;&lt;p&gt;hello &lt;br/&gt; world&lt;/p&gt;&lt;hr/&gt;&lt;/body&gt;&lt;/html&gt; 文本格式化 标签 描述 &lt;b&gt; 加粗 &lt;big&gt; 大号字体 &lt;em&gt; 着重文字 &lt;i&gt; 斜体 &lt;small&gt; 小号字体 &lt;sub&gt; 下标 &lt;sup&gt; 上标 超链接&lt;a&gt;比较重要的属性有两个，分别是href、targethref指定超链接地址target指定打开方式&emsp;_blank 新页面打开 普通链接&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; 邮件链接标签最简式&lt;a href=&quot;mailto:xxx@xx.com&quot;&gt;联系站长&lt;/a&gt; 图像使用格式：&lt;img src=&quot;url&quot;&gt;&emsp;alt 定义当图片无法加载时，显示什么信息&emsp;width 定义宽度，单位可以为像素 也可以为百分比&emsp;height 定义高度&lt; img src=“11.jpg” width=&quot;100px&quot; height=&quot;200px&quot; title=&quot;title&quot; alt=&quot;图片无法显示，请刷新&quot;/&gt; 表格表格由&lt;table&gt;来定义，每行&lt;tr&gt; 有许多单元格&lt;td&gt;。表头可以使用&lt;th&gt;&lt;table&gt;标签属性： border：表格边框属性；当使用border=”1”设置边框时，会在所有td以及table上嵌套边框，当border加大时，只有table框会加粗。cellspacing：单元格与单元格之间的间隙。当cellspacing=”0”时，单元格之间的间隙为0，但边框线并不会合并。☆☆合并边框的写法style=”border-collapse:collapse;” 使用边框合并时，无需设置cellspacing。cellpadding:单元格内边距，单元格中文字与单元格边框之间的距离。width/height:表格的宽高align：设置表格在父容器中的对齐方式 ，left/居左 center/居中 right/居右☆☆当表格使用align属性时，相当于使表格浮动，可能会导致表格后面的元素受表格浮动影响，导致布局错乱。bgcolor：背景色background：背景图，后接相对路径。背景图和背景色同时生效时，图会覆盖背景色bordercolor：设置边框颜色 在&lt;table&gt;中可以嵌入&lt;th&gt; &lt;tr&gt; &lt;td&gt;等标签 &lt;tr&gt; 定义行 &lt;th&gt; 定义表头 colspan 定义表头单元格可以横跨的列数。 rowspan 定义表头单元格横跨的行数 heardes 定义与表头单元格相关联的一个或者多个单元格。(html5新增) &lt;td&gt; 定义单元格 colspan 定义单元格可以横跨的列数。 rowspan 定义单元格横跨的行数 heardes 定义与单元格相关联的一个或者多个单元格。(html5新增) 表格固定高度：overflow-y:auto; 列表无序列表&lt;ul&gt;有序列表&lt;ol&gt; 123456789&lt;ul&gt; &lt;li&gt;male&lt;/li&gt; &lt;li&gt;female&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;ol&gt; &lt;li&gt;male&lt;/li&gt; &lt;li&gt;female&lt;/li&gt;&lt;/ol&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content type="text"><![CDATA[非打印字符非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列： 字符 描述 \cx 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 \r 匹配一个回车符。等价于 \x0d 和 \cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 特殊字符 字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 | 指明两项之间的一个选择。要匹配 |，请使用 |。 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 \、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配* 定位符定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\b 描述单词的前或后边界，\B 表示非单词边界。正则表达式的定位符有： 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 \b 匹配一个单词边界，即字与空格间的位置。 \B 非单词边界匹配。 注意：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现场问题整理]]></title>
    <url>%2F%E7%8E%B0%E5%9C%BA%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86.html</url>
    <content type="text"><![CDATA[通讯测试串口测试车辆通讯问题SendID：0730；RecvID：073833 33 07 38 FF FF 88 88 设置滤波 只接收ID为0738的指令55 55 07 30 02 10 03 00 00 00 00 00 88 88 发送指令 发送ID为0730其中： 02 10 03 00 00 00 00 00 为CAN指令，第一位为长度位。 四轮大灯四轮设备中文乱码导致数据上传失败解决方法 更改时间、区域为China 详情请咨询 Coulsonxia 宝骏现场大灯数据单独上传实现方法 流程中新建TCPClient用于接收大灯通讯启动大灯需要发送车型信息，格式为：{0x02}{车辆信息_ToHLA_ZTS};{车辆信息_ToHLA_VIN}{0x0D}{0x0A}接收解析并保存大灯数据]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>现场问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现场软件备份路径]]></title>
    <url>%2F%E7%8E%B0%E5%9C%BA%E8%BD%AF%E4%BB%B6%E5%A4%87%E4%BB%BD%E8%B7%AF%E5%BE%84.html</url>
    <content type="text"><![CDATA[网盘中软件工程下有相应文件夹的上传在相应文件夹中，没有的上传在对应项目文件夹中，后期会提醒Dean在软件工程中新建相应文件夹。Z:\4-软件共享John\软件工程 网盘地址内网：http://192.168.1.80:5000/外网：https://bbknick.synology.me:5001/ 北汽莱西被动式ACC更新时间：20190806 Z:\6-项目管理Jason\2018\218039 北汽新能源莱西工厂一套驾驶辅助标定设备项目-Jones\17-现场设备调试程序 北汽昆明更新时间：20190806 Z:\6-项目管理Jason\2017\117314 北汽新能源汽车工程技术中心（昆明）检测线项目-Jones\17-现场设备调试程序\设备程序 众泰贵港腾骏更新时间：20190806 Z:\4-软件共享John\软件工程\腾骏\腾骏贵港]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>现场软件备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库导入导出]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html</url>
    <content type="text"><![CDATA[Postgresql测试软件导出、Postgresql导入测试软件导出 连接数据库设置完筛选条件后点击导出到Excel重命名为：表名.csv 测试软件导入 1、打开导出表添加新的数据后，删除第一行表头以及第一列序号2、删除原数据库已有行后保存3、打开Postgres找到相应表右键导入4、文件名选择csv文件路径、格式选csv、字符编码可选5、点击导入即可 如果主键为自增序列执行6、76、将相应表的序列创建脚本后删除7、更改脚本中的START大于新增数据的主键ID后执行脚本 SQL shell(psql)导入 1、将excel处理好后，另存为csv（Comma Delimited）2、运行SQL shell(psql) 并登录3、运行’COPY mytable FROM ‘/myfile.csv’ WITH CSV HEADER SQL shell(psql)导出 COPY (select * from mytable) to ‘/myfile.csv’ with csv header;]]></content>
      <categories>
        <category>工作</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无处安放的矫情]]></title>
    <url>%2F%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE%E7%9A%84%E7%9F%AB%E6%83%85.html</url>
    <content type="text"><![CDATA[Enter password to read！ Incorrect Password! No content to display! U2FsdGVkX19qdSl1LEos9Q6JCAE5x4MxTDV7C/tEDgc=]]></content>
  </entry>
  <entry>
    <title><![CDATA[C# XML]]></title>
    <url>%2FC%23%20XML.html</url>
    <content type="text"><![CDATA[XML创建、读取配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071static public void WirteConfig(string FileName, string KeyName, string Value)&#123; try &#123; string FilePath = OnlyOneStartUp.UseConfigPath; string AllFileName = FilePath + "\\" + FileName + ".xml"; if (!Directory.Exists(FilePath)) Directory.CreateDirectory(FilePath); DataSet ds = new DataSet(); if (File.Exists(AllFileName)) ds.ReadXml(AllFileName); if (ds.Tables.Count &lt; 1) ds.Tables.Add(); if (ds.Tables[0].Rows.Count &lt; 1) ds.Tables[0].Rows.Add(); if (!ds.Tables[0].Columns.Contains(KeyName)) ds.Tables[0].Columns.Add(KeyName); ds.Tables[0].Rows[0][KeyName] = Value; ds.WriteXml(AllFileName); &#125; catch (Exception e) &#123; string sError = string.Format("写入配置信息Error:&#123;0&#125;", e.Message); ErrorOut(MethodInfo.GetCurrentMethod().Name, sError); &#125;&#125;/// &lt;summary&gt;/// 读出配置文件/// &lt;/summary&gt;/// &lt;param name="FileName"&gt;配置文件名称&lt;/param&gt;/// &lt;param name="KeyName"&gt;键名&lt;/param&gt;/// &lt;param name="Value"&gt;返回的值&lt;/param&gt;static public bool ReadConfig(string FileName, string KeyName, ref string Value)&#123; try &#123; string FilePath = OnlyOneStartUp.UseConfigPath; string AllFileName = FilePath + "\\" + FileName + ".xml"; if (!Directory.Exists(FilePath)) return false; DataSet ds = new DataSet(); if (File.Exists(AllFileName)) ds.ReadXml(AllFileName); else return false; if (ds.Tables.Count &lt; 1) return false; if (ds.Tables[0].Rows.Count &lt; 1) return false; if (!ds.Tables[0].Columns.Contains(KeyName)) return false; Value = Convert.ToString(ds.Tables[0].Rows[0][KeyName]); return true; &#125; catch (Exception e) &#123; string sError = string.Format("读取配置信息Error:&#123;0&#125;", e.Message); ErrorOut(MethodInfo.GetCurrentMethod().Name, sError); return false; &#125;&#125;static public void ReadConfigEx(string FileName, string KeyName, ref string Value)&#123; if (!ReadConfig(FileName, KeyName, ref Value)) WirteConfig(FileName, KeyName, Value);&#125;]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据转换]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2.html</url>
    <content type="text"><![CDATA[IEEE to Double、Char、int在线转换工具http://www.binaryconvert.com C# IEEE to Single123456789101112131415161718192021222324252627private Single IEEE2Single(byte[] b)&#123; try &#123; Array.Reverse(b); Single d = BitConverter.ToSingle(b, 0); return (Single)Math.Round(d, 5); &#125; catch (System.Exception ex) &#123; return 0; &#125;&#125;private byte[] SingleToIEEE(Single d)&#123; try &#123; byte[] b = new byte[]&#123;&#125;; b = BitConverter.GetBytes(d); Array.Reverse(b); return b; &#125; catch (System.Exception ex) &#123; return new byte[] &#123; 0x00, 0x00, 0x00, 0x00&#125;; &#125;&#125; 3CA97E13-&gt;0.02069 格式转换Double to Hex12345int Height_LF = (int)Convert.ToDouble(XmlFO.ListObject["WBH_LF"].xValue);Height_RR *= 4;string s = string.Empty;s = s + ((byte)(Height_LF &gt;&gt; 8)).ToString("x2")+ " ";s = s + ((byte)(Height_LF)).ToString("x2") + " "; 2700-&gt;0a 8c Byte to uint1234567891011121314151617181920uint BytesToUint(byte[] bys)&#123; uint ReVal = 0; foreach (byte b in bys) &#123; ReVal &lt;&lt;= 8; ReVal += b; &#125; return ReVal;&#125;byte[] UintToBytes(uint UnVal, int Count)&#123; byte[] ReVal = new byte[Count]; for (int i = 0; i &lt; Count; i++) &#123; ReVal[Count - i - 1] = (byte)(UnVal &gt;&gt; (i * 8)); &#125; return ReVal;&#125; Int to Byte1234567891011121314151617181920212223242526272829public xState ToByte(string sPara)&#123; try &#123; string[] SepPara; if (!XmlFO.SepParams(sPara, 2, out SepPara)) return xState.xError; xBytes tmpbyte = (xBytes)XmlFO.GetCheckSpecTypeObject(SepPara[0], typeof(xBytes)); if (tmpbyte == null) return xState.xError; int Count = Convert.ToInt32(SepPara[1]); if (Count &gt; 4) Count = 4; if (Count &lt; 1) Count = 1; Byte[] TmpByte = new byte[Count]; for (int i = 0; i &lt; Count; i++) &#123; TmpByte[i] = (byte)((iValue &gt;&gt; ((Count - i - 1) * 8)) &amp; 0xFF); &#125; tmpbyte.Bytes = TmpByte; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125; Byte123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442public byte[] xHexToBytes(string InStr)&#123; if (!InStr.StartsWith("0x")) return System.Text.Encoding.GetEncoding(cPage).GetBytes(InStr); InStr = InStr.Substring(2); string NSpaceStr = InStr.Replace(" ", string.Empty); List&lt;byte&gt; ReByte = new List&lt;byte&gt;(); for (int i = 0; i &lt; NSpaceStr.Length / 2; i++) &#123; ReByte.Add(Convert.ToByte(NSpaceStr.Substring(i * 2, 2), 16)); &#125; return ReByte.ToArray();&#125;public byte[] StringAnaToBytes(string StrAna)&#123; List&lt;byte&gt; ReByte = new List&lt;byte&gt;(); try &#123; string[] strs = StrAna.Split('&#123;', '&#125;'); for (int i = 0; i &lt; strs.Length; i++) &#123; if (i % 2 == 0) ReByte.AddRange(System.Text.Encoding.GetEncoding(cPage).GetBytes(strs[i])); else ReByte.AddRange(xHexToBytes(strs[i])); &#125; &#125; catch (Exception e) &#123; string xError = string.Format("字符串转换到BYTE失败Error:&#123;0&#125; 字串：&#123;1&#125;", e.Message, StrAna); xErrorOut(MethodInfo.GetCurrentMethod().Name, xError); &#125; return ReByte.ToArray();&#125;public string PackBytes(byte[] ArrByte)&#123; string ReStr = "&#123;0x"; foreach (byte b in ArrByte) &#123; ReStr += b.ToString("X2"); &#125; ReStr += "&#125;"; return ReStr;&#125;public int cPage = Encoding.Default.CodePage;public byte[] StringToBytes(string InValue)&#123; string str = XmlFO.StringAnalysis(InValue); return StringAnaToBytes(str);&#125;public string BytesToString(byte[] InBytes)&#123; return System.Text.Encoding.GetEncoding(cPage).GetString(Bytes);&#125;public xState ToString(string sPara)&#123; try &#123; XmlFO.ListObject[sPara].xValue = BytesToString(Bytes); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState ToInt(string sPara)&#123; try &#123; xInt TmpInt = (xInt)XmlFO.GetCheckSpecTypeObject(sPara, typeof(xInt)); if (TmpInt == null) return xState.xError; int Count = Bytes.Length; int NumTmp = 0; if (Count &gt; 0) &#123; NumTmp = (sbyte)Bytes[0]; if (Count &gt; 4) Count = 4; for (int i = 1; i &lt; Count; i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; &#125; TmpInt.iValue = NumTmp; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState ToInt_MinusSign(string sPara)&#123; try &#123; xInt TmpInt = (xInt)XmlFO.GetCheckSpecTypeObject(sPara, typeof(xInt)); if (TmpInt == null) return xState.xError; int Count = Bytes.Length; int NumTmp = 0; if (Count &gt; 0) &#123; NumTmp = (Bytes[0] &amp; 0x7F); if (Count &gt; 4) Count = 4; for (int i = 1; i &lt; Count; i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; if (Bytes[0] &gt; 0x7F) NumTmp = -NumTmp; &#125; TmpInt.iValue = NumTmp; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState ToInt_Uint(string sPara)&#123; try &#123; xInt TmpInt = (xInt)XmlFO.GetCheckSpecTypeObject(sPara, typeof(xInt)); if (TmpInt == null) return xState.xError; int Count = Bytes.Length; int NumTmp = 0; if (Count &gt; 0) &#123; NumTmp = Bytes[0]; if (Count &gt; 4) Count = 4; for (int i = 1; i &lt; Count; i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; &#125; TmpInt.iValue = NumTmp; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState CopyFrom(string sPara)&#123; try &#123; xBytes TmpByte = (xBytes)XmlFO.GetCheckSpecTypeObject(sPara, typeof(xBytes)); if (TmpByte == null) return xState.xError; if (TmpByte.cPage != cPage) Bytes = Encoding.Convert(Encoding.GetEncoding(TmpByte.cPage), Encoding.GetEncoding(cPage), TmpByte.Bytes); else Bytes = TmpByte.Bytes.ToArray(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState SubByteFrom(string sPara)&#123; try &#123; string[] SepPara; if (!XmlFO.SepParams(sPara, 3, out SepPara)) return xState.xError; List&lt;Byte&gt; tmpByte = new List&lt;byte&gt;(); tmpByte.AddRange(StringToBytes(SepPara[0])); if (tmpByte.Count &gt; 0) &#123; int start = Convert.ToInt32(SepPara[1]);//start 0 int leng = Convert.ToInt32(SepPara[2]); if (start &gt;= tmpByte.Count) start = tmpByte.Count - 1; if ((start + leng) &gt; tmpByte.Count) leng = tmpByte.Count - start; Bytes = tmpByte.GetRange(start, leng).ToArray(); &#125; else Bytes = tmpByte.ToArray(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState IsEqual(string sPara)&#123; try &#123; string[] SepPara; if (!XmlFO.SepParams(sPara, 2, out SepPara)) return xState.xError; byte[] tmpByte = StringToBytes(SepPara[0]); int start = Convert.ToInt32(SepPara[1]);//start 0 if ((start + tmpByte.Length) &gt; Bytes.Length) return xState.xFalse; for (int i = 0; i &lt; tmpByte.Length; i++) &#123; if (tmpByte[i] != Bytes[start + i]) return xState.xFalse; &#125; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState CheckBit(string sPara)&#123; try &#123; string[] SepPara; if (!XmlFO.SepParams(sPara, 2, out SepPara)) return xState.xError; int byteNo = Convert.ToInt32(SepPara[0]);//start 0 int bitNo = Convert.ToInt32(SepPara[1]);//start 7---0 if (bitNo &gt; 7) bitNo = 7; if (bitNo &lt; 0) bitNo = 0; int Num = (Bytes[byteNo] &lt;&lt; (7 - bitNo)) &amp; 0xFF; Num = (Num &gt;&gt; 7) &amp; 0xFF; if (Num == 1) return xState.xTrue; else return xState.xFalse; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState UseDefaultCodePage(string sPara)&#123; cPage = Encoding.Default.CodePage; return xState.xTrue;&#125;public xState UseUTF8CodePage(string sPara)&#123; cPage = Encoding.UTF8.CodePage; return xState.xTrue;&#125;public xState UseUnicodeCodePage(string sPara)&#123; cPage = Encoding.Unicode.CodePage; return xState.xTrue;&#125;//转换public xState Convert_String_ASCII(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, Bytes.Length); XmlFO.ListObject[Sep.sName].xValue = Encoding.ASCII.GetString(Bytes, Sep.iStart, Sep.iCount); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_String_BCD(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, Bytes.Length); string strTmp = string.Empty; for (int i = Sep.iStart; (i &lt; Bytes.Length) &amp;&amp; (i &lt; (Sep.iStart + Sep.iCount)); i++) strTmp += Bytes[i].ToString("X2"); XmlFO.ListObject[Sep.sName].xValue = strTmp; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_Double(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 1); int NumTmp = 0; for (int i = Sep.iStart; (i &lt; Bytes.Length) &amp;&amp; (i &lt; (Sep.iStart + Sep.iCount)); i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; double DoubTmp = (NumTmp * Sep.dRadio + Sep.dOffset); XmlFO.ListObject[Sep.sName].xValue = DoubTmp.ToString(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_Double_Bit(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 1); double NumTmp = 0; if (Sep.iCount &gt; 4) NumTmp = BitConverter.ToDouble(Bytes, Sep.iStart); else NumTmp = BitConverter.ToSingle(Bytes, Sep.iStart); double DoubTmp = (NumTmp * Sep.dRadio + Sep.dOffset); XmlFO.ListObject[Sep.sName].xValue = DoubTmp.ToString(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_Double_Minus(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 1); int NumTmp = (Bytes[0] &amp; 0x7F); for (int i = (Sep.iStart + 1); (i &lt; Bytes.Length) &amp;&amp; (i &lt; (Sep.iStart + Sep.iCount)); i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; if (Bytes[0] &gt; 0x7F) NumTmp = -NumTmp; double DoubTmp = (NumTmp * Sep.dRadio + Sep.dOffset); XmlFO.ListObject[Sep.sName].xValue = DoubTmp.ToString(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_Int(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 1); int NumTmp = 0; for (int i = Sep.iStart; (i &lt; Bytes.Length) &amp;&amp; (i &lt; (Sep.iStart + Sep.iCount)); i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; NumTmp = (int)(NumTmp * Sep.dRadio + Sep.dOffset); XmlFO.ListObject[Sep.sName].xValue = NumTmp.ToString(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_Int_Bit(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 1); int NumTmp = 0; if (Sep.iCount &gt; 4) NumTmp = (int)BitConverter.ToInt64(Bytes, Sep.iStart); else if (Sep.iCount &gt; 2) NumTmp = (int)BitConverter.ToInt32(Bytes, Sep.iStart); else if (Sep.iCount &gt; 1) NumTmp = (int)BitConverter.ToInt16(Bytes, Sep.iStart); else NumTmp = Bytes[Sep.iStart]; NumTmp = (int)(NumTmp * Sep.dRadio + Sep.dOffset); XmlFO.ListObject[Sep.sName].xValue = NumTmp.ToString(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Append_Double(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 4); int iTmp = (int)(Convert.ToDouble(XmlFO.ListObject[Sep.sName].xValue) * Sep.dRadio + Sep.dOffset); List&lt;Byte&gt; ListTmp = new List&lt;byte&gt;(); ListTmp.AddRange(Bytes); for (int i = 0; i &lt; Sep.iCount; i++) &#123; ListTmp.Add((byte)((iTmp &gt;&gt; ((Sep.iCount - i - 1) * 8)) &amp; 0xFF)); &#125; Bytes = ListTmp.ToArray(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;]]></content>
      <categories>
        <category>数据转换</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>IEEE</tag>
        <tag>Hex</tag>
        <tag>Double</tag>
        <tag>Byte</tag>
        <tag>int</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RGB颜色]]></title>
    <url>%2FRGB%E9%A2%9C%E8%89%B2.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>RGB</category>
      </categories>
      <tags>
        <tag>RGB颜色表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常用属性]]></title>
    <url>%2Fcss%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7.html</url>
    <content type="text"><![CDATA[文本设置123456789101112font: italic bold 36px 宋体; //顺序不可变font-wight: 100-900、bold（加粗）font-size: 10px; // 12px(12像素)、50%、larger、smallfont-style: initial（初始）、italic（斜体字）、normal（默认）、oblique（倾斜）font-family: "微软雅黑" // 宋体text-align: center; //横向排列 left、right 和 centerline-height: 200px; //文本行高 通俗的讲，文字高度加上文字上下的空白区域的高度 50%:基于字体大小的百分比vertical-align:-4px; //设置元素内容的垂直对齐方式 ,只对行内元素有效，对块级元素无效text-indent: 150px; //首行缩进letter-spacing: 10px; //字母间隙word-spacing: 20px; //单词间隙text-transform: capitalize; //单词大写 背景属性1234567background-color: cornflowerblue; //背景颜色background-image: url('1.jpg'); //背景图片background-repeat: no-repeat/repeat-x/repeat=t; //(默认铺满，不重复，x重复，y重复)background-size:600px 250px //大小background-position: right top（20px 20px）;//(横向：left center right)(纵向：top center bottom) //简写：&lt;body style="background: 20px 20px no-repeat #ff4 url('1.jpg')"&gt;&lt;div style="width: 300px;height: 300px;background: 20px 20px no-repeat #ff4 url('1.jpg')"&gt; 颜色属性1234&lt;div style="color:blueviolet"&gt;ppppp&lt;/div&gt; //颜色少&lt;div style="color:#ffee33"&gt;ppppp&lt;/div&gt; //百度颜色代码可以查询更多&lt;div style="color:rgb(255,0,0)"&gt;ppppp&lt;/div&gt; //三原色 红绿蓝256级&lt;div style="color:rgba(255,0,0,0.5)"&gt;ppppp&lt;/div&gt; //比上一个 加了一个透明度]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型的特点]]></title>
    <url>%2F%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9.html</url>
    <content type="text"><![CDATA[泛型的主要特性泛型类型的一些重要特征使它们相比传统的非泛型类型具有如下的显著特征： 类型安全性能二进制代码复用 类型安全泛型最重要的特征之一是类型安全性。对于非泛型ArrayList类，如果使用对象类型，则可以向集合中添加任何类型，这些类型有时会导致严重的问题。下面的示例显示向ArrayList类型的集合添加一个整数、字符串和对象； 1234ArrayList obj = new ArrayList(); obj.Add(50); obj.Add("Dog"); obj.Add(new TestClass()); 现在，如果使用整数对象来使用foreach语句进行遍历的话，当编译器接受到代码，但是因为集合中的所有元素都不是整数，所以会导致运行时异常； 1234foreach(int i in obj) &#123; Console.WriteLine(i); &#125; 编程的经验法则是应该尽早检测到错误。对于泛型类Test，泛型类型T定义允许哪些类型。通过使用Test的定义，只能向集合添加整型类型的数据。这时候当Add()方法具有以下无效参数的时候编译器将不编译代码； 1234Test&lt;int&gt; obj = new Test&lt;int&gt;(); obj.Add(50); obj.Add("Dog"); //编译错误obj.Add(new TestClass()); //编译错误 性能在下面的示例中，ArrayList类存储对象，并且定义了Add()方法来存储一些整型参数。因此，整数类型被装箱。当使用foreach语句读取ArrayList中的值时，将发生拆箱。 1234567ArrayList obj = new ArrayList(); obj.Add(50); //装箱- 值类型转换成引用类型int x= (int)obj[0]; //拆箱foreach(int i in obj) &#123; Console.WriteLine(i); // 拆箱&#125; 注意：泛型比其他集合（如ArrayList）更快。 代替使用对象类型，TestClass类的泛型类型被定义为int，因此在从编译器动态生成的类中将使用int类型。所以将不会发生装箱和拆箱，如下所示； 1234567TestClass&lt;int&gt; obj = new TestClass&lt;int&gt;(); obj.Add(50); //没有装箱int x= obj[0]; // 没有拆箱foreach(int i in obj) &#123; Console.WriteLine(i); //没有拆箱&#125; 二进制代码复用泛型类型提供了一种源代码保护机制。泛型类可以定义一次，并且可以使用许多不同类型来进行实例化。泛型可以在一种CLR支持的语言中定义，并可以被另一种.NET语言使用。以下TestClass 使用int和string类型进行实例化： 12345TestClass&lt;int&gt; obj = new TestClass&lt;int&gt;(); obj.Add(50); TestClass&lt;string&gt; obj1 = new TestClass&lt;string&gt;(); Obj1.Add("hello");]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# Static]]></title>
    <url>%2FC%23%20Static.html</url>
    <content type="text"><![CDATA[静态方法只能访问类的静态成员，不能访问类的非静态成员；非静态方法可以访问类的静态成员，也可以访问类的非静态成员；静态方法不能使用实例来调用，只能使用类名来调用。 static静态全局变量 特点： 1、该变量在全局数据区分配内存。2、初始化：如果不显式初始化，那么将被隐式初始化为0。 静态局部变量 特点： 1、该变量在全局数据区分配内存。2、初始化：如果不显式初始化，那么将被隐式初始化为0。3、它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。 静态数据成员 内存分配：在程序的全局数据区分配。初始化和定义： 1、静态数据成员定义时要分配空间，所以不能在类声明中定义。2、为了避免在多个使用该类的源文件中，对其重复定义，所以，不能在类的头文件中定义。3、静态数据成员因为程序一开始运行就必需存在，所以其初始化的最佳位置在类的内部实现。 特点 对相于 public,protected,private 关键字的影响它和普通数据成员一样，因为其空间在全局数据区分配，属于所有本类的对象共享，所以，它不属于特定的类对象，在没产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它。 访问形式 类对象名.静态数据成员名 静态数据成员，主要用在类的所有实例都拥有的属性上。比如，对于一个存款类，帐号相对于每个实例都是不同的，但每个实例的利息是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局区的内存，所以节省存贮空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了，因为它们实际上是共用一个东西。 静态成员函数 特点： 1、静态成员函数与类相联系，不与类的对象相联系。2、静态成员函数不能访问非静态数据成员。原因很简单，非静态数据成员属于特定的类实例。 作用： 主要用于对静态数据成员的操作。 调用形式： 类对象名.静态成员函数名（） 总结静态方法只能访问类的静态成员，不能访问类的非静态成员；非静态方法可以访问类的静态成员，也可以访问类的非静态成员；静态方法不能使用实例来调用，只能使用类名来调用。 12345678910111213static int i = getNum();int j = getNum();static int num = 1;static int getNum()&#123; return num;&#125;static void Main(string[] args)&#123; Console.WriteLine("i=&#123;0&#125;",i); Console.WriteLine("j=&#123;0&#125;", new class1().j); Console.Read();&#125; 分析：Console.WriteLine(&quot;i={0}&quot;,i);这里i是static变量，而且类class1是第一次被引用，要先为class1里面所有的static变量分配内存。尽管现在有超线程技术，但是指令在逻辑还是一条一条的按顺序执行的，所以先为static int i分配内存，并且在该内存中保持int的缺省值0，接着再为static int num 变量分配内存，值当然也为0。 然后执行第二步，为变量赋值：先为static int i变量赋值，i＝getNum()，看getNum里面的代码，就是return num，这个时候num的值是0，于是i就为0了。然后对变量num赋值，num＝1；这行代码执行后，num就为1了。 static的优点是什么？为什么要使用static 变量或函数？？有一些频繁使用的东西，如果你每次使用都重新new一下，那么这个开销可能会很高，如果使用static，一直放在内存中，那么想用就直接用，而不需要重新new一块空间初始化数据。那么static就是为了实现一个系统的缓存作用的，其生命周期直到应用程序退出结束。 静态成员包括静态字段和静态属性，静态成员和类相关联，不依赖于对象而存在，只能由类访问，而不能由对象访问； 静态成员属于类所有，无认创建多少实例对象，静态成员在内存中只有一份；实例成员属于类的实例所有，每创建一个实例对象，实例成员都会在内存中分配一块内存区域。所以静态成员一般用于存放共享的数据段，如数据库连接字符串等。 一个类如果只包含静态成员和静态方法，则该类可以定义为静态类，给类加上static修饰符； 静态方法和非静态方法：一、性能上：静态方法和实例方法差别不大。所有方法，不管是静态方法还是实例方法，都是在JIT加载类时分配内存，不同的是静态方法以类名引用，而实例方法对对象实例引用。创建实例时，不会再为类的方法分配内存，所有的实例对象共用一个类的方法代码。因此静态方法和实例方法的调用，在性能上的差别微乎其微。 二、静态方法只能由类访问；实例方法只能由对象访问。 优点： 1、静态变量在类载入时，就装入内存2、使用时不用 New 就意味的不必 创建类中 所有对象，就可以调用 某个方法 缺点： 垃圾回收机制 不能 回收 静态变量，静态类变量 会常驻内存 c#中静态类的优缺点 缺点： 1、整个类型在程序运行期间只加载一次。 这样是对于那些经常使用的类型来说的，那就不用每次使用前都先加载。效率高些。但是对那些不常用的类型来说。2、如果是静态类型，那就要一直占用相当的内存；一直到程序停止。或者应用程序域被卸载。所以应该只对那些常用的类型定义成静态类型。 优点： 1、它们仅包含静态成员。2、它们不能被实例化。3、它们是密封的。4、它们不能包含实例构造函数（C# 编程指南）。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 常识]]></title>
    <url>%2FC%23%20%E5%B8%B8%E8%AF%86.html</url>
    <content type="text"><![CDATA[记录写bug过程中遇到的一些疑问 数据类型值类型存储在堆栈上，引用类型存储在堆上。C#类为引用类型，结构为值类型。从值类型转化为引用类型称为装箱，如果方法需要把一个对象作为参数，而且传送一个值类型，装箱操作会自动进行；装箱的值类型可以使用拆箱操作转换为值类型，在拆箱时，需要使用类型转换运算符。 装箱和拆箱装箱是一种通过将变量存储到System.Object中来显式地将值类型转换为引用类型的机制。当您装入值时，CLR会将新对象分配到堆中，并将值类型的值复制到该实例中。例如： 12int a = 20; object b = a; //装箱 相反的操作是拆箱，它是将引用类型转换回值类型的过程。此过程验证接收数据类型是否与装箱类型一致;int c = (int)b; // 拆箱 泛型 特征： 类型安全性能二进制代码复用 详见： 泛型的特点 为什么不用object代替泛型由于Object为所有类型的基类，所以可以处理任何数据类型的数据，但是其中存在这拆箱和装箱，如果数据太多会影响到程序的性能。在使用泛型的时候程序会在编译阶段根据我们提供的类型生成相应的二进制代码，无须进行装箱和拆箱操作。 接口为什么要用接口接口一般由上层人员发起，下层人员实现。写接口并不是为了扩展，而是为了扩展以后的模块仍然跟项目模块保持高度一致，为了扩展后的规范化。 实例化接口对象接口回调接口不仅可以声明对象，而且可以把对象实例化，还可以当做参数被传入。即继承中的向上转型，父类 FL=new 子类()，只不过这里的父类就是interface接口。 12345678910111213141516171819202122232425interface Itemp&#123; double plus();&#125;public class num : Itemp&#123; double aa, bb; public num(double a, double b) &#123; this.bb = b; this.aa = a; &#125; public double plus() &#123; return (aa + bb); &#125;&#125;static void Main(string[] args)&#123; Itemp tm = null;//声明接口对象引用 tm = new num(1, 2);//接口回调(向上转型) Console.WriteLine(tm.plus());&#125; 类型参数约束&emsp;&emsp;在定义泛型类时，可以对客户端代码能够在实例化类时用于类型参数的类型种类施加限制。如果客户端代码尝试使用某个约束所不允许的类型来实例化类，则会产生编译时错误。这些限制称为约束。类型参数约束.NET支持的类型参数约束有以下五种： 123456where T : struct 类型参数必须是值类型；可以指定除 Nullable 以外的任何值类型where T : class 类型参数必须是引用类型；这一点也适用于任何类、接口、委托或数组类型where T : new() 类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new() 约束必须最后指定where T : NameOfBaseClass 类型参数必须是指定的基类或派生自指定的基类where T : NameOfInterface 类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的where T : U 为 T 提供的类型参数必须是为 U 提供的参数或派生自为 U 提供的参数]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客部署到Coding和github]]></title>
    <url>%2FHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0Coding%E5%92%8Cgithub.html</url>
    <content type="text"><![CDATA[部署到Github和Coding新建仓库 Github：新建Repository：name.github.io Coding：新建Repository：name.coding.me 添加SSH key若无SSHkey ssh-keygen -t rsa -C “your e-mail”Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 打开生成的id_rsa.pub文件并复制其中的内容添加到Github或Coding项目中然后在git中执行 Github： ssh -T git@github.com Coding： ssh -T git@git.coding.net //coding ssh -T git@git.dev.tencent.com //腾讯云 添加到腾讯云后需要开启Pages服务才可通过name.coding.me登录 更改博客配置文件123456deploy: type: git repository: github: git@github.com:silencejql/silencejql.github.io.git coding: git@git.dev.tencent.com:silencejql/silencejql.coding.me.git branch: master 不同格式相应作出调整即可 可能出现的问题http://name.coding.me 在google chrome中打开可能会默认https，修复方式为: 地址栏中输入 chrome://net-internals/#hsts在 Delete domain security policies 中输入项目的域名，并 Delete 删除可以在 Query domain 测试是否删除成功 这里如果还是不行， 请清除浏览器缓存！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Coding</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[托管DLL与非托管DLL]]></title>
    <url>%2F%E6%89%98%E7%AE%A1DLL%E4%B8%8E%E9%9D%9E%E6%89%98%E7%AE%A1DLL.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;托管DLL和非托管DLL的区别：狭义解释讲，托管DLL就在Dotnet环境生成的DLL文件；非托管DLL不是在Dotnet环境生成的DLL文件。&emsp;&emsp;托管DLL文件，可以在Dotnet环境通过 “添加引用” 的方式，直接把托管DLL文件添加到项目中，然后通过 Using DLL命名空间，来调用相应的DLL对象；非托管DLL文件，在Dotnet环境应用时，通过DllImport 调用。 概述&emsp;&emsp;托管dll虽然符合windows的PE格式规范，但是代码是以IL的形式保存在.Text 区的，而不是机器码，CLR会在运行时JIT编译成机器码再交给操作系统执行，这也就为什么托管代码称之为”托管”的意义。&emsp;&emsp;所以，要想注入托管dll，首先需要在目标进程中启动CLR，然后让CLR来加载managed dll。&emsp;&emsp;托管DLL，指完全由.NET托管代码实现的DLL，完全依赖于 .NET 平台的 CLR 运行。托管DLL，受.NET CLR管控，支持内存自动回收等的，对于.NET平台是安全DLL&emsp;&emsp;非托管DLL，是指完全或者部分 不是用.NET代码实现，不依赖于.NET平台即可运行，例如 COM方式 的DLL，不支持自动回收内存，对于.NET平台而言，也是非安全可控的。 &emsp;&emsp;正常编程所用的高级语言，是无法被计算机识别的。需要先将高级语言翻译为机器语言，才能被机器理解和运行。在标准C/C++中，编译过程是这样的：&emsp;&emsp;源代码首先经过预处理器，对头文件以及宏进行解析，然后经过编译器，生成汇编代码，接着，经过汇编，生成机器指令，最后将所有文件连接起来。这种编译方式的优点在于，最终直接生成了机器码，可以直接被计算机识别和运行，无需任何中间运行环境，但缺点也在于，由于不同平台能够识别的机器码不同，因此程序的跨平台能力较差。&emsp;&emsp;而在Java语言中，源代码并没有被直接翻译成机器码，而是编译成了一种中间代码（字节码Bytecode）。因此，运行Java程序需要一个额外的JRE（Java Runtime Enviromental）运行环境，在JRE中存在着JVM（Java Virtual Mechinal，Java虚拟机），在程序运行的时候，会将中间代码进一步解释为机器码，并在机器上运行。&emsp;&emsp;使用中间代码的好处在于，程序的跨平台性比较好，一次编译，可以在不同的设备上运行。&emsp;&emsp;托管/非托管是微软的.net framework中特有的概念，其中，非托管代码也叫本地（native）代码。与Java中的机制类似，也是先将源代码编译成中间代码（MSIL，Microsoft Intermediate Language），然后再由.net中的CLR将中间代码编译成机器代码。&emsp;&emsp;而C#与Java的区别在于，Java是先编译后解释，C#是两次编译。 调用DLL中的非托管函数一般方法首先，应该在C#语言源程序中声明外部方法，其基本形式是： [DLLImport(“DLL文件”)]修饰符 extern 返回变量类型 方法名称 （参数列表）其中： DLL文件：包含定义外部方法的库文件。修饰符： 访问修饰符，除了abstract以外在声明方法时可以使用的修饰符。返回变量类型：在DLL文件中你需调用方法的返回变量类型。方法名称：在DLL文件中你需调用方法的名称。参数列表：在DLL文件中你需调用方法的列表。 注意：需要在程序声明中使用System.Runtime.InteropServices命名空间。DllImport只能放置在方法声明上。DLL文件必须位于程序当前目录或系统定义的查询路径中（即：系统环境变量中Path所设置的路径）。返回变量类型、方法名称、参数列表一定要与DLL文件中的定义相一致。若要使用其它函数名，可以使用EntryPoint属性设置，如： 12345[DllImport("user32.dll", EntryPoint="MessageBoxA")]static extern int MsgBox(int hWnd, string msg, string caption, int type);[DllImportAttribute("CN210S_CSM_LV1.dll", EntryPoint = "uds_calc_key", CharSet = CharSet.Ansi)]private static extern void uds_calc_key_ldw(string seed, StringBuilder key); 其它可选的 DllImportAttribute 属性： CharSet： 指示用在入口点中的字符集，如：CharSet=CharSet.Ansi；SetLastError： 指示方法是否保留 Win32”上一错误”，如：SetLastError=true；ExactSpelling： 指示 EntryPoint 是否必须与指示的入口点的拼写完全匹配，如：ExactSpelling=false；PreserveSig： 指示方法的签名应当被保留还是被转换， 如：PreserveSig=true；CallingConvention： 指示入口点的调用约定， 如：CallingConvention=CallingConvention.Winapi；]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>托管DLL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[委托-匿名-Lambda表达式]]></title>
    <url>%2F%E5%A7%94%E6%89%98-%E5%8C%BF%E5%90%8D-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content type="text"><![CDATA[委托123456789101112131415161718192021222324252627282930313233delegate int calculator(int x, int y); //委托类型static void Main()&#123; calculator add = new calculator(Addition); int AddResult = add(1, 1); Console.Write(AddResult); calculator dec = new calculator(Subtraction); int SubResult = dec(2,1); Console.write(SubResult);&#125;/// &lt;summary&gt;/// 加法/// &lt;/summary&gt;/// &lt;param name="x"&gt;&lt;/param&gt;/// &lt;param name="y"&gt;&lt;/param&gt;/// &lt;returns&gt;x+y&lt;/returns&gt;public static int Addition(int x, int y)&#123; return x + y;&#125;/// &lt;summary&gt;/// 减法/// &lt;/summary&gt;/// &lt;param name="x"&gt;&lt;/param&gt;/// &lt;param name="y"&gt;&lt;/param&gt;/// &lt;returns&gt;x-y&lt;/returns&gt;public static int Subtraction(int x, int y)&#123; return x - y;&#125; 匿名方法12345678910111213141516delegate int calculator(int x, int y); //委托static void Main()&#123; calculator add = delegate(int num1,int num2) &#123; return num1 + num2; &#125;; calculator dec = delegate(int num1,int num2) &#123; return num1 - num2; &#125;; int AddResult = dec(1, 1); int SubResult = dec(2, 1); Console.Write(AddResult); Console.Write(SubResult);&#125; Lambda表达式1234567891011121314151617181920212223242526272829303132333435363738delegate bool MyBol(int x, int y);delegate bool MyBol_2(int x, string y);delegate int calculator(int x, int y); //委托类型delegate void VS();static void Main()&#123; MyBol Bol = (x, y) =&gt; x == y; MyBol_2 Bol_2 = (x, s) =&gt; s.Length &gt; x; calculator C = (X, Y) =&gt; X * Y; VS S = () =&gt; Console.Write("我是无参数Labada表达式"); int[] numbers = &#123; 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 &#125;; int oddNumbers = numbers.Count(n =&gt; n % 2 == 1); List&lt;People&gt; people = LoadData();//初始化 IEnumerable&lt;People&gt; results = people.Where(delegate(People p) &#123; return p.age &gt; 20; &#125;);&#125;private static List&lt;People&gt; LoadData()&#123; List&lt;People&gt; people = new List&lt;People&gt;(); //创建泛型对象 People p1 = new People(21, "guojing"); //创建一个对象 People p2 = new People(21, "wujunmin"); //创建一个对象 People p3 = new People(20, "muqing"); //创建一个对象 People p4 = new People(23, "lupan"); //创建一个对象 people.Add(p1); //添加一个对象 people.Add(p2); //添加一个对象 people.Add(p3); //添加一个对象 people.Add(p4); return people;&#125;public class People&#123; public int age &#123; get; set; &#125; //设置属性 public string name &#123; get; set; &#125; //设置属性 public People(int age, string name) //设置属性(构造函数构造) &#123; this.age = age; //初始化属性值age this.name = name; //初始化属性值name &#125;&#125; Func委托1234567891011121314//最后一个参数为返回值类型static void Main(string[] args)&#123; Func&lt;int, int, bool&gt; gwl = (p, j) =&gt; &#123; if (p + j == 10) &#123; return true; &#125; return false; &#125;; Console.WriteLine(gwl(5,5) + ""); //打印‘True’ Console.ReadKey();&#125;]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>委托</tag>
        <tag>匿名方法</tag>
        <tag>Lambda</tag>
        <tag>Func&lt;T&gt;委托</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Markdown]]></title>
    <url>%2FHexo%20Markdown.html</url>
    <content type="text"><![CDATA[Hexo指令新建文章12345678$ hexo new 布局 &quot;文章名&quot;$ hexo clean //清除静态页面缓存（清除 public 文件夹) $ hexo g //在本地生成静态页面（生成 public 文件夹） $ hexo s //启动本地服务 http://localhost:4000，进行预览调试 $ hexo d //远程部署，同步到 GitHub $ npm install hexo-deployer-git --save //自动部署$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d //发布 Markdown格式首行缩进&amp;ensp; //相当于1个空格 &amp;emsp; //相当于2个空格，1个汉字 分段: 两个回车换行: 两个空格 + 回车标题: # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题 强调123*斜体* | **加粗** | ***斜体加粗*** _斜体_ | __加粗__ | ___斜体加粗___ ~~删除线~~ 引用: &gt; 注意后面紧跟个空格 123&gt; 以下为引用效果继续引用&gt; &gt;二级引用 以下为引用效果继续引用 二级引用 表格: - 和 | 分割行和列 ， : 控制对齐方式 12345| 0 | 1 | 2|| :- | -: | :-: || 0 | 1 | 2 || 0 | 1 | 2 || 0 | 1 | 2 | 0 1 2 0 1 2 0 1 2 0 1 2 代码块: 四个空格开头或三个链接:文字邮件链接：xxx` 图片: ![图片说明](图片地址)，地址可以是本地路径，也可以是网络地址列表: * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格 设置字体段落格式1234&lt;center&gt;居中&lt;/center&gt;&lt;font color=&quot;#FF0000&quot;&gt; 设置颜色 &lt;/font&gt; &lt;font size=6&gt; 设置大小 &lt;/font&gt;&lt;font size=5 color=&quot;#FF0000&quot;&gt; 设置颜色和大小&lt;/font&gt; 居中 设置颜色 设置大小 设置颜色和大小 引用站内文章在写文章的过程中，有时候需要引用站内的其他文章。可以通过内置的标签插件的语法post_link来实现引用。 Hexo主题设计头像头像配置文件位于：主题配置文件中的 avatar下 版权信息版权信息的配置文件位于：next\layout\_macro\my-copyright中 添加文章密码方法一(测试可用)安装hexo-blog-encrypt根目录的package.json文件夹中添加： 1&quot;hexo-blog-encrypt&quot;: &quot;2.0.*&quot; 然后在命令行输入： 1npm install 根目录下的_config.yml文件中添加： 123# Securityencrypt: enable: true 使用在需要加密的文章头部写入password： 123password: abc123abstract: Welcome to my blog, enter password to read.message: Welcome to my blog, enter password to read. 方法二在 themes-&gt;next-&gt;layout-&gt;\_partials-&gt;head.swig 中添加下面内容 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误,交钱还是跑路？'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章头部加入password。 添加边栏背景图在 themes\next\source\css\_custom\custom.styl文件中添加 12345678.sidebar &#123; background: url([https://ws2.sinaimg.cn/large/006tKfTcly1fq2wrm6g3cj309i0hq749.jpg](https://ws2.sinaimg.cn/large/006tKfTcly1fq2wrm6g3cj309i0hq749.jpg "https://ws2.sinaimg.cn/large/006tKfTcly1fq2wrm6g3cj309i0hq749.jpg")) no-repeat !important; background-size: cover !important; position: fixed !important; right: 0 !important; top: 0 !important; bottom: 0 !important;&#125; 网易云音乐插件主题文件夹layout\\\_custom\\sidebar.swig Warning: LF will be replaced by CRLFgit config --global core.autocrlf false //禁用自动转换 更改文章全局属性(标题)D:\GitProject\FirstHexo\themes\next\source\css\_common\components\post\post.styl 文章模板在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：hexo new photo “My Gallery”，在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md模板，并根据其内容建立文章，默认使用_config.yml 中的 default_layout 参数post代替]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>主题</tag>
        <tag>文章密码</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碎碎念]]></title>
    <url>%2F%E7%A2%8E%E7%A2%8E%E5%BF%B5.html</url>
    <content type="text"><![CDATA[Enter password to read！ Incorrect Password! No content to display! U2FsdGVkX1/Fr6zWo59DkYEisoaFgTM44cL+vlZOIB0mD0EnQ4Evdbp45yEWH4LUKi7l1zsYX6Adwu5orrX/478yYzLkMaST5Jur9w0fKMvJhP1y/rMVRW7Qe+qKW2oosFAmftRCSKQUK6rZ9GTdeIQiNn668acFbkQQ7dFglR4MSjgXLH0Ck7Aqq5QXtGgnWmhSLCZLMPSbCf4C2c+d1Mary+7M2wZvJYKYu9WbYKXScStXKWOKsO3AMI0zM/u6dh75fWg+2z0gw/D6DvrzoYRADotLumqNK6UBXgjV4KmQaQIjRM8cKCJi2Ai9N8gJe6sv8huXbfbh48muGjTspfw8IZ90YLgO9ciAPT3Lg0cdRzRQ2NLnBnBbYBEaDYEAuij38c7USmsmLQuKzfe9i3f5vgjDQK+jicaWzIGE2OHWveZ2jiF/EPg+P1WZBxgJf9/CIr7tQ1Dd9rW1ZrX+tCJY2MadJUobM6Te5uQmFs5rc/8Uc/OhcL3GaxC4uWGnJzMKan3qJ8EiBihnLGK4fftyMEnz5nTxQJbP7NYIEmQWnIPgs9eQ3fRGDicEL7Drdt+0ZD7/FPNhzlyw1pRktJ80lA2izQx7qyfKhZEcWbHzZ4uYKh59qLFEXs+zBq5QctfIu6UqBVzKD8s9jWNexxQ8NchgbbYIWsZYejGtglNkh90O55Ex5KhPlcqcM7IS]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test Project]]></title>
    <url>%2FTest%20Project.html</url>
    <content type="text"><![CDATA[Test Filethis is my first Hexo text file]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
</search>
