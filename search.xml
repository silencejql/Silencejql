<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Postgresql数据导入导出]]></title>
    <url>%2F2019%2F07%2F30%2FPostgresql%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%2F</url>
    <content type="text"><![CDATA[测试软件导出、Postgresql导入测试软件导出 连接数据库设置完筛选条件后点击导出到Excel重命名为：表名.csv 测试软件导入 1、打开导出表添加新的数据后，删除第一行表头以及第一列序号2、删除原数据库已有行后保存3、打开Postgres找到相应表右键导入4、文件名选择csv文件路径、格式选csv、字符编码可选5、点击导入即可 6、如果主键为自增序列，将相应表的序列创建脚本后删除7、更改脚本中的START大于新增数据的主键ID后执行脚本 SQL shell(psql)导入 1、将excel处理好后，另存为csv（Comma Delimited）2、运行SQL shell(psql) 并登录3、运行’COPY mytable FROM ‘/myfile.csv’ WITH CSV HEADER SQL shell(psql)导出 COPY (select * from mytable) to ‘/myfile.csv’ with csv header;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无处安放的矫情]]></title>
    <url>%2F2019%2F07%2F22%2F%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE%E7%9A%84%E7%9F%AB%E6%83%85%2F</url>
    <content type="text"><![CDATA[Enter password to read！ Incorrect Password! No content to display! U2FsdGVkX1+sTaajXkj/mFDMwWNOAuk4WoIJmEQwB50=]]></content>
  </entry>
  <entry>
    <title><![CDATA[C# XML]]></title>
    <url>%2F2019%2F07%2F11%2FC-XML%2F</url>
    <content type="text"><![CDATA[XML创建、读取配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071static public void WirteConfig(string FileName, string KeyName, string Value)&#123; try &#123; string FilePath = OnlyOneStartUp.UseConfigPath; string AllFileName = FilePath + "\\" + FileName + ".xml"; if (!Directory.Exists(FilePath)) Directory.CreateDirectory(FilePath); DataSet ds = new DataSet(); if (File.Exists(AllFileName)) ds.ReadXml(AllFileName); if (ds.Tables.Count &lt; 1) ds.Tables.Add(); if (ds.Tables[0].Rows.Count &lt; 1) ds.Tables[0].Rows.Add(); if (!ds.Tables[0].Columns.Contains(KeyName)) ds.Tables[0].Columns.Add(KeyName); ds.Tables[0].Rows[0][KeyName] = Value; ds.WriteXml(AllFileName); &#125; catch (Exception e) &#123; string sError = string.Format("写入配置信息Error:&#123;0&#125;", e.Message); ErrorOut(MethodInfo.GetCurrentMethod().Name, sError); &#125;&#125;/// &lt;summary&gt;/// 读出配置文件/// &lt;/summary&gt;/// &lt;param name="FileName"&gt;配置文件名称&lt;/param&gt;/// &lt;param name="KeyName"&gt;键名&lt;/param&gt;/// &lt;param name="Value"&gt;返回的值&lt;/param&gt;static public bool ReadConfig(string FileName, string KeyName, ref string Value)&#123; try &#123; string FilePath = OnlyOneStartUp.UseConfigPath; string AllFileName = FilePath + "\\" + FileName + ".xml"; if (!Directory.Exists(FilePath)) return false; DataSet ds = new DataSet(); if (File.Exists(AllFileName)) ds.ReadXml(AllFileName); else return false; if (ds.Tables.Count &lt; 1) return false; if (ds.Tables[0].Rows.Count &lt; 1) return false; if (!ds.Tables[0].Columns.Contains(KeyName)) return false; Value = Convert.ToString(ds.Tables[0].Rows[0][KeyName]); return true; &#125; catch (Exception e) &#123; string sError = string.Format("读取配置信息Error:&#123;0&#125;", e.Message); ErrorOut(MethodInfo.GetCurrentMethod().Name, sError); return false; &#125;&#125;static public void ReadConfigEx(string FileName, string KeyName, ref string Value)&#123; if (!ReadConfig(FileName, KeyName, ref Value)) WirteConfig(FileName, KeyName, Value);&#125;]]></content>
      <categories>
        <category>C#</category>
        <category>XML</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据转换]]></title>
    <url>%2F2019%2F07%2F11%2F%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[IEEE to Double、Char、int在线转换工具http://www.binaryconvert.com C# IEEE to Single123456789101112131415161718192021222324252627private Single IEEE2Single(byte[] b)&#123; try &#123; Array.Reverse(b); Single d = BitConverter.ToSingle(b, 0); return (Single)Math.Round(d, 5); &#125; catch (System.Exception ex) &#123; return 0; &#125;&#125;private byte[] SingleToIEEE(Single d)&#123; try &#123; byte[] b = new byte[]&#123;&#125;; b = BitConverter.GetBytes(d); Array.Reverse(b); return b; &#125; catch (System.Exception ex) &#123; return new byte[] &#123; 0x00, 0x00, 0x00, 0x00&#125;; &#125;&#125; 3CA97E13-&gt;0.02069 格式转换Double to Hex12345int Height_LF = (int)Convert.ToDouble(XmlFO.ListObject["WBH_LF"].xValue);Height_RR *= 4;string s = string.Empty;s = s + ((byte)(Height_LF &gt;&gt; 8)).ToString("x2")+ " ";s = s + ((byte)(Height_LF)).ToString("x2") + " "; 2700-&gt;0a 8c Byte to uint1234567891011121314151617181920uint BytesToUint(byte[] bys)&#123; uint ReVal = 0; foreach (byte b in bys) &#123; ReVal &lt;&lt;= 8; ReVal += b; &#125; return ReVal;&#125;byte[] UintToBytes(uint UnVal, int Count)&#123; byte[] ReVal = new byte[Count]; for (int i = 0; i &lt; Count; i++) &#123; ReVal[Count - i - 1] = (byte)(UnVal &gt;&gt; (i * 8)); &#125; return ReVal;&#125; Int to Byte1234567891011121314151617181920212223242526272829public xState ToByte(string sPara)&#123; try &#123; string[] SepPara; if (!XmlFO.SepParams(sPara, 2, out SepPara)) return xState.xError; xBytes tmpbyte = (xBytes)XmlFO.GetCheckSpecTypeObject(SepPara[0], typeof(xBytes)); if (tmpbyte == null) return xState.xError; int Count = Convert.ToInt32(SepPara[1]); if (Count &gt; 4) Count = 4; if (Count &lt; 1) Count = 1; Byte[] TmpByte = new byte[Count]; for (int i = 0; i &lt; Count; i++) &#123; TmpByte[i] = (byte)((iValue &gt;&gt; ((Count - i - 1) * 8)) &amp; 0xFF); &#125; tmpbyte.Bytes = TmpByte; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125; Byte123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442public byte[] xHexToBytes(string InStr)&#123; if (!InStr.StartsWith("0x")) return System.Text.Encoding.GetEncoding(cPage).GetBytes(InStr); InStr = InStr.Substring(2); string NSpaceStr = InStr.Replace(" ", string.Empty); List&lt;byte&gt; ReByte = new List&lt;byte&gt;(); for (int i = 0; i &lt; NSpaceStr.Length / 2; i++) &#123; ReByte.Add(Convert.ToByte(NSpaceStr.Substring(i * 2, 2), 16)); &#125; return ReByte.ToArray();&#125;public byte[] StringAnaToBytes(string StrAna)&#123; List&lt;byte&gt; ReByte = new List&lt;byte&gt;(); try &#123; string[] strs = StrAna.Split('&#123;', '&#125;'); for (int i = 0; i &lt; strs.Length; i++) &#123; if (i % 2 == 0) ReByte.AddRange(System.Text.Encoding.GetEncoding(cPage).GetBytes(strs[i])); else ReByte.AddRange(xHexToBytes(strs[i])); &#125; &#125; catch (Exception e) &#123; string xError = string.Format("字符串转换到BYTE失败Error:&#123;0&#125; 字串：&#123;1&#125;", e.Message, StrAna); xErrorOut(MethodInfo.GetCurrentMethod().Name, xError); &#125; return ReByte.ToArray();&#125;public string PackBytes(byte[] ArrByte)&#123; string ReStr = "&#123;0x"; foreach (byte b in ArrByte) &#123; ReStr += b.ToString("X2"); &#125; ReStr += "&#125;"; return ReStr;&#125;public int cPage = Encoding.Default.CodePage;public byte[] StringToBytes(string InValue)&#123; string str = XmlFO.StringAnalysis(InValue); return StringAnaToBytes(str);&#125;public string BytesToString(byte[] InBytes)&#123; return System.Text.Encoding.GetEncoding(cPage).GetString(Bytes);&#125;public xState ToString(string sPara)&#123; try &#123; XmlFO.ListObject[sPara].xValue = BytesToString(Bytes); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState ToInt(string sPara)&#123; try &#123; xInt TmpInt = (xInt)XmlFO.GetCheckSpecTypeObject(sPara, typeof(xInt)); if (TmpInt == null) return xState.xError; int Count = Bytes.Length; int NumTmp = 0; if (Count &gt; 0) &#123; NumTmp = (sbyte)Bytes[0]; if (Count &gt; 4) Count = 4; for (int i = 1; i &lt; Count; i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; &#125; TmpInt.iValue = NumTmp; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState ToInt_MinusSign(string sPara)&#123; try &#123; xInt TmpInt = (xInt)XmlFO.GetCheckSpecTypeObject(sPara, typeof(xInt)); if (TmpInt == null) return xState.xError; int Count = Bytes.Length; int NumTmp = 0; if (Count &gt; 0) &#123; NumTmp = (Bytes[0] &amp; 0x7F); if (Count &gt; 4) Count = 4; for (int i = 1; i &lt; Count; i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; if (Bytes[0] &gt; 0x7F) NumTmp = -NumTmp; &#125; TmpInt.iValue = NumTmp; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState ToInt_Uint(string sPara)&#123; try &#123; xInt TmpInt = (xInt)XmlFO.GetCheckSpecTypeObject(sPara, typeof(xInt)); if (TmpInt == null) return xState.xError; int Count = Bytes.Length; int NumTmp = 0; if (Count &gt; 0) &#123; NumTmp = Bytes[0]; if (Count &gt; 4) Count = 4; for (int i = 1; i &lt; Count; i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; &#125; TmpInt.iValue = NumTmp; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState CopyFrom(string sPara)&#123; try &#123; xBytes TmpByte = (xBytes)XmlFO.GetCheckSpecTypeObject(sPara, typeof(xBytes)); if (TmpByte == null) return xState.xError; if (TmpByte.cPage != cPage) Bytes = Encoding.Convert(Encoding.GetEncoding(TmpByte.cPage), Encoding.GetEncoding(cPage), TmpByte.Bytes); else Bytes = TmpByte.Bytes.ToArray(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState SubByteFrom(string sPara)&#123; try &#123; string[] SepPara; if (!XmlFO.SepParams(sPara, 3, out SepPara)) return xState.xError; List&lt;Byte&gt; tmpByte = new List&lt;byte&gt;(); tmpByte.AddRange(StringToBytes(SepPara[0])); if (tmpByte.Count &gt; 0) &#123; int start = Convert.ToInt32(SepPara[1]);//start 0 int leng = Convert.ToInt32(SepPara[2]); if (start &gt;= tmpByte.Count) start = tmpByte.Count - 1; if ((start + leng) &gt; tmpByte.Count) leng = tmpByte.Count - start; Bytes = tmpByte.GetRange(start, leng).ToArray(); &#125; else Bytes = tmpByte.ToArray(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState IsEqual(string sPara)&#123; try &#123; string[] SepPara; if (!XmlFO.SepParams(sPara, 2, out SepPara)) return xState.xError; byte[] tmpByte = StringToBytes(SepPara[0]); int start = Convert.ToInt32(SepPara[1]);//start 0 if ((start + tmpByte.Length) &gt; Bytes.Length) return xState.xFalse; for (int i = 0; i &lt; tmpByte.Length; i++) &#123; if (tmpByte[i] != Bytes[start + i]) return xState.xFalse; &#125; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState CheckBit(string sPara)&#123; try &#123; string[] SepPara; if (!XmlFO.SepParams(sPara, 2, out SepPara)) return xState.xError; int byteNo = Convert.ToInt32(SepPara[0]);//start 0 int bitNo = Convert.ToInt32(SepPara[1]);//start 7---0 if (bitNo &gt; 7) bitNo = 7; if (bitNo &lt; 0) bitNo = 0; int Num = (Bytes[byteNo] &lt;&lt; (7 - bitNo)) &amp; 0xFF; Num = (Num &gt;&gt; 7) &amp; 0xFF; if (Num == 1) return xState.xTrue; else return xState.xFalse; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState UseDefaultCodePage(string sPara)&#123; cPage = Encoding.Default.CodePage; return xState.xTrue;&#125;public xState UseUTF8CodePage(string sPara)&#123; cPage = Encoding.UTF8.CodePage; return xState.xTrue;&#125;public xState UseUnicodeCodePage(string sPara)&#123; cPage = Encoding.Unicode.CodePage; return xState.xTrue;&#125;//转换public xState Convert_String_ASCII(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, Bytes.Length); XmlFO.ListObject[Sep.sName].xValue = Encoding.ASCII.GetString(Bytes, Sep.iStart, Sep.iCount); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_String_BCD(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, Bytes.Length); string strTmp = string.Empty; for (int i = Sep.iStart; (i &lt; Bytes.Length) &amp;&amp; (i &lt; (Sep.iStart + Sep.iCount)); i++) strTmp += Bytes[i].ToString("X2"); XmlFO.ListObject[Sep.sName].xValue = strTmp; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_Double(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 1); int NumTmp = 0; for (int i = Sep.iStart; (i &lt; Bytes.Length) &amp;&amp; (i &lt; (Sep.iStart + Sep.iCount)); i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; double DoubTmp = (NumTmp * Sep.dRadio + Sep.dOffset); XmlFO.ListObject[Sep.sName].xValue = DoubTmp.ToString(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_Double_Bit(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 1); double NumTmp = 0; if (Sep.iCount &gt; 4) NumTmp = BitConverter.ToDouble(Bytes, Sep.iStart); else NumTmp = BitConverter.ToSingle(Bytes, Sep.iStart); double DoubTmp = (NumTmp * Sep.dRadio + Sep.dOffset); XmlFO.ListObject[Sep.sName].xValue = DoubTmp.ToString(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_Double_Minus(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 1); int NumTmp = (Bytes[0] &amp; 0x7F); for (int i = (Sep.iStart + 1); (i &lt; Bytes.Length) &amp;&amp; (i &lt; (Sep.iStart + Sep.iCount)); i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; if (Bytes[0] &gt; 0x7F) NumTmp = -NumTmp; double DoubTmp = (NumTmp * Sep.dRadio + Sep.dOffset); XmlFO.ListObject[Sep.sName].xValue = DoubTmp.ToString(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_Int(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 1); int NumTmp = 0; for (int i = Sep.iStart; (i &lt; Bytes.Length) &amp;&amp; (i &lt; (Sep.iStart + Sep.iCount)); i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; NumTmp = (int)(NumTmp * Sep.dRadio + Sep.dOffset); XmlFO.ListObject[Sep.sName].xValue = NumTmp.ToString(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_Int_Bit(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 1); int NumTmp = 0; if (Sep.iCount &gt; 4) NumTmp = (int)BitConverter.ToInt64(Bytes, Sep.iStart); else if (Sep.iCount &gt; 2) NumTmp = (int)BitConverter.ToInt32(Bytes, Sep.iStart); else if (Sep.iCount &gt; 1) NumTmp = (int)BitConverter.ToInt16(Bytes, Sep.iStart); else NumTmp = Bytes[Sep.iStart]; NumTmp = (int)(NumTmp * Sep.dRadio + Sep.dOffset); XmlFO.ListObject[Sep.sName].xValue = NumTmp.ToString(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Append_Double(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 4); int iTmp = (int)(Convert.ToDouble(XmlFO.ListObject[Sep.sName].xValue) * Sep.dRadio + Sep.dOffset); List&lt;Byte&gt; ListTmp = new List&lt;byte&gt;(); ListTmp.AddRange(Bytes); for (int i = 0; i &lt; Sep.iCount; i++) &#123; ListTmp.Add((byte)((iTmp &gt;&gt; ((Sep.iCount - i - 1) * 8)) &amp; 0xFF)); &#125; Bytes = ListTmp.ToArray(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;]]></content>
      <categories>
        <category>数据转换</category>
        <category>IEEE</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>IEEE</tag>
        <tag>Hex</tag>
        <tag>Double</tag>
        <tag>Byte</tag>
        <tag>int</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RGB颜色]]></title>
    <url>%2F2019%2F07%2F05%2FRGB%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>RGB</category>
      </categories>
      <tags>
        <tag>RGB颜色表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常用属性]]></title>
    <url>%2F2019%2F07%2F05%2Fcss%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[文本设置123456789101112font: italic bold 36px 宋体; //顺序不可变font-wight: 100-900、bold（加粗）font-size: 10px; // 12px(12像素)、50%、larger、smallfont-style: initial（初始）、italic（斜体字）、normal（默认）、oblique（倾斜）font-family: "微软雅黑" // 宋体text-align: center; //横向排列 left、right 和 centerline-height: 200px; //文本行高 通俗的讲，文字高度加上文字上下的空白区域的高度 50%:基于字体大小的百分比vertical-align:-4px; //设置元素内容的垂直对齐方式 ,只对行内元素有效，对块级元素无效text-indent: 150px; //首行缩进letter-spacing: 10px; //字母间隙word-spacing: 20px; //单词间隙text-transform: capitalize; //单词大写 背景属性1234567background-color: cornflowerblue; //背景颜色background-image: url('1.jpg'); //背景图片background-repeat: no-repeat/repeat-x/repeat=t; //(默认铺满，不重复，x重复，y重复)background-size:600px 250px //大小background-position: right top（20px 20px）;//(横向：left center right)(纵向：top center bottom) //简写：&lt;body style="background: 20px 20px no-repeat #ff4 url('1.jpg')"&gt;&lt;div style="width: 300px;height: 300px;background: 20px 20px no-repeat #ff4 url('1.jpg')"&gt; 颜色属性1234&lt;div style="color:blueviolet"&gt;ppppp&lt;/div&gt; //颜色少&lt;div style="color:#ffee33"&gt;ppppp&lt;/div&gt; //百度颜色代码可以查询更多&lt;div style="color:rgb(255,0,0)"&gt;ppppp&lt;/div&gt; //三原色 红绿蓝256级&lt;div style="color:rgba(255,0,0,0.5)"&gt;ppppp&lt;/div&gt; //比上一个 加了一个透明度]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型的特点]]></title>
    <url>%2F2019%2F07%2F05%2F%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[泛型的主要特性泛型类型的一些重要特征使它们相比传统的非泛型类型具有如下的显著特征： 类型安全性能二进制代码复用 类型安全泛型最重要的特征之一是类型安全性。对于非泛型ArrayList类，如果使用对象类型，则可以向集合中添加任何类型，这些类型有时会导致严重的问题。下面的示例显示向ArrayList类型的集合添加一个整数、字符串和对象； 1234ArrayList obj = new ArrayList(); obj.Add(50); obj.Add("Dog"); obj.Add(new TestClass()); 现在，如果使用整数对象来使用foreach语句进行遍历的话，当编译器接受到代码，但是因为集合中的所有元素都不是整数，所以会导致运行时异常； 1234foreach(int i in obj) &#123; Console.WriteLine(i); &#125; 编程的经验法则是应该尽早检测到错误。对于泛型类Test，泛型类型T定义允许哪些类型。通过使用Test的定义，只能向集合添加整型类型的数据。这时候当Add()方法具有以下无效参数的时候编译器将不编译代码； 1234Test&lt;int&gt; obj = new Test&lt;int&gt;(); obj.Add(50); obj.Add("Dog"); //编译错误obj.Add(new TestClass()); //编译错误 性能在下面的示例中，ArrayList类存储对象，并且定义了Add()方法来存储一些整型参数。因此，整数类型被装箱。当使用foreach语句读取ArrayList中的值时，将发生拆箱。 1234567ArrayList obj = new ArrayList(); obj.Add(50); //装箱- 值类型转换成引用类型int x= (int)obj[0]; //拆箱foreach(int i in obj) &#123; Console.WriteLine(i); // 拆箱&#125; 注意：泛型比其他集合（如ArrayList）更快。 代替使用对象类型，TestClass类的泛型类型被定义为int，因此在从编译器动态生成的类中将使用int类型。所以将不会发生装箱和拆箱，如下所示； 1234567TestClass&lt;int&gt; obj = new TestClass&lt;int&gt;(); obj.Add(50); //没有装箱int x= obj[0]; // 没有拆箱foreach(int i in obj) &#123; Console.WriteLine(i); //没有拆箱&#125; 二进制代码复用泛型类型提供了一种源代码保护机制。泛型类可以定义一次，并且可以使用许多不同类型来进行实例化。泛型可以在一种CLR支持的语言中定义，并可以被另一种.NET语言使用。以下TestClass 使用int和string类型进行实例化： 12345TestClass&lt;int&gt; obj = new TestClass&lt;int&gt;(); obj.Add(50); TestClass&lt;string&gt; obj1 = new TestClass&lt;string&gt;(); Obj1.Add("hello");]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# Static]]></title>
    <url>%2F2019%2F07%2F05%2FC-Static%2F</url>
    <content type="text"><![CDATA[静态方法只能访问类的静态成员，不能访问类的非静态成员；非静态方法可以访问类的静态成员，也可以访问类的非静态成员；静态方法不能使用实例来调用，只能使用类名来调用。 static静态全局变量 特点： 1、该变量在全局数据区分配内存。2、初始化：如果不显式初始化，那么将被隐式初始化为0。 静态局部变量 特点： 1、该变量在全局数据区分配内存。2、初始化：如果不显式初始化，那么将被隐式初始化为0。3、它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。 静态数据成员 内存分配：在程序的全局数据区分配。初始化和定义： 1、静态数据成员定义时要分配空间，所以不能在类声明中定义。2、为了避免在多个使用该类的源文件中，对其重复定义，所以，不能在类的头文件中定义。3、静态数据成员因为程序一开始运行就必需存在，所以其初始化的最佳位置在类的内部实现。 特点 对相于 public,protected,private 关键字的影响它和普通数据成员一样，因为其空间在全局数据区分配，属于所有本类的对象共享，所以，它不属于特定的类对象，在没产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它。 访问形式 类对象名.静态数据成员名 静态数据成员，主要用在类的所有实例都拥有的属性上。比如，对于一个存款类，帐号相对于每个实例都是不同的，但每个实例的利息是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局区的内存，所以节省存贮空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了，因为它们实际上是共用一个东西。 静态成员函数 特点： 1、静态成员函数与类相联系，不与类的对象相联系。2、静态成员函数不能访问非静态数据成员。原因很简单，非静态数据成员属于特定的类实例。 作用： 主要用于对静态数据成员的操作。 调用形式： 类对象名.静态成员函数名（） 总结静态方法只能访问类的静态成员，不能访问类的非静态成员；非静态方法可以访问类的静态成员，也可以访问类的非静态成员；静态方法不能使用实例来调用，只能使用类名来调用。 12345678910111213static int i = getNum();int j = getNum();static int num = 1;static int getNum()&#123; return num;&#125;static void Main(string[] args)&#123; Console.WriteLine("i=&#123;0&#125;",i); Console.WriteLine("j=&#123;0&#125;", new class1().j); Console.Read();&#125; 分析：Console.WriteLine(&quot;i={0}&quot;,i);这里i是static变量，而且类class1是第一次被引用，要先为class1里面所有的static变量分配内存。尽管现在有超线程技术，但是指令在逻辑还是一条一条的按顺序执行的，所以先为static int i分配内存，并且在该内存中保持int的缺省值0，接着再为static int num 变量分配内存，值当然也为0。 然后执行第二步，为变量赋值：先为static int i变量赋值，i＝getNum()，看getNum里面的代码，就是return num，这个时候num的值是0，于是i就为0了。然后对变量num赋值，num＝1；这行代码执行后，num就为1了。 static的优点是什么？为什么要使用static 变量或函数？？有一些频繁使用的东西，如果你每次使用都重新new一下，那么这个开销可能会很高，如果使用static，一直放在内存中，那么想用就直接用，而不需要重新new一块空间初始化数据。那么static就是为了实现一个系统的缓存作用的，其生命周期直到应用程序退出结束。 静态成员包括静态字段和静态属性，静态成员和类相关联，不依赖于对象而存在，只能由类访问，而不能由对象访问； 静态成员属于类所有，无认创建多少实例对象，静态成员在内存中只有一份；实例成员属于类的实例所有，每创建一个实例对象，实例成员都会在内存中分配一块内存区域。所以静态成员一般用于存放共享的数据段，如数据库连接字符串等。 一个类如果只包含静态成员和静态方法，则该类可以定义为静态类，给类加上static修饰符； 静态方法和非静态方法：一、性能上：静态方法和实例方法差别不大。所有方法，不管是静态方法还是实例方法，都是在JIT加载类时分配内存，不同的是静态方法以类名引用，而实例方法对对象实例引用。创建实例时，不会再为类的方法分配内存，所有的实例对象共用一个类的方法代码。因此静态方法和实例方法的调用，在性能上的差别微乎其微。 二、静态方法只能由类访问；实例方法只能由对象访问。 优点： 1、静态变量在类载入时，就装入内存2、使用时不用 New 就意味的不必 创建类中 所有对象，就可以调用 某个方法 缺点： 垃圾回收机制 不能 回收 静态变量，静态类变量 会常驻内存 c#中静态类的优缺点 缺点： 1、整个类型在程序运行期间只加载一次。 这样是对于那些经常使用的类型来说的，那就不用每次使用前都先加载。效率高些。但是对那些不常用的类型来说。2、如果是静态类型，那就要一直占用相当的内存；一直到程序停止。或者应用程序域被卸载。所以应该只对那些常用的类型定义成静态类型。 优点： 1、它们仅包含静态成员。2、它们不能被实例化。3、它们是密封的。4、它们不能包含实例构造函数（C# 编程指南）。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 常识]]></title>
    <url>%2F2019%2F07%2F05%2FC-%E5%B8%B8%E8%AF%86%2F</url>
    <content type="text"><![CDATA[记录写bug过程中遇到的一些疑问 数据类型值类型存储在堆栈上，引用类型存储在堆上。C#类为引用类型，结构为值类型。从值类型转化为引用类型称为装箱，如果方法需要把一个对象作为参数，而且传送一个值类型，装箱操作会自动进行；装箱的值类型可以使用拆箱操作转换为值类型，在拆箱时，需要使用类型转换运算符。 装箱和拆箱装箱是一种通过将变量存储到System.Object中来显式地将值类型转换为引用类型的机制。当您装入值时，CLR会将新对象分配到堆中，并将值类型的值复制到该实例中。例如： 12int a = 20; object b = a; //装箱 相反的操作是拆箱，它是将引用类型转换回值类型的过程。此过程验证接收数据类型是否与装箱类型一致;int c = (int)b; // 拆箱 泛型 特征： 类型安全性能二进制代码复用 详见： 泛型的特点 为什么不用object代替泛型由于Object为所有类型的基类，所以可以处理任何数据类型的数据，但是其中存在这拆箱和装箱，如果数据太多会影响到程序的性能。在使用泛型的时候程序会在编译阶段根据我们提供的类型生成相应的二进制代码，无须进行装箱和拆箱操作。 接口为什么要用接口接口一般由上层人员发起，下层人员实现。写接口并不是为了扩展，而是为了扩展以后的模块仍然跟项目模块保持高度一致，为了扩展后的规范化。 实例化接口对象接口回调接口不仅可以声明对象，而且可以把对象实例化，还可以当做参数被传入。即继承中的向上转型，父类 FL=new 子类()，只不过这里的父类就是interface接口。 12345678910111213141516171819202122232425interface Itemp&#123; double plus();&#125;public class num : Itemp&#123; double aa, bb; public num(double a, double b) &#123; this.bb = b; this.aa = a; &#125; public double plus() &#123; return (aa + bb); &#125;&#125;static void Main(string[] args)&#123; Itemp tm = null;//声明接口对象引用 tm = new num(1, 2);//接口回调(向上转型) Console.WriteLine(tm.plus());&#125; 类型参数约束&emsp;&emsp;在定义泛型类时，可以对客户端代码能够在实例化类时用于类型参数的类型种类施加限制。如果客户端代码尝试使用某个约束所不允许的类型来实例化类，则会产生编译时错误。这些限制称为约束。类型参数约束.NET支持的类型参数约束有以下五种： 123456where T : struct 类型参数必须是值类型；可以指定除 Nullable 以外的任何值类型where T : class 类型参数必须是引用类型；这一点也适用于任何类、接口、委托或数组类型where T : new() 类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new() 约束必须最后指定where T : NameOfBaseClass 类型参数必须是指定的基类或派生自指定的基类where T : NameOfInterface 类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的where T : U 为 T 提供的类型参数必须是为 U 提供的参数或派生自为 U 提供的参数]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客部署到Coding和github]]></title>
    <url>%2F2019%2F07%2F04%2FHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0Coding%E5%92%8Cgithub%2F</url>
    <content type="text"><![CDATA[部署到Github和Coding新建仓库 Github：新建Repository：name.github.io Coding：新建Repository：name.coding.me 添加SSH key若无SSHkey ssh-keygen -t rsa -C “your e-mail”Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 打开生成的id_rsa.pub文件并复制其中的内容添加到Github或Coding项目中然后在git中执行 Github： ssh -T git@github.com Coding： ssh -T git@git.coding.net //coding ssh -T git@git.dev.tencent.com //腾讯云 添加到腾讯云后需要开启Pages服务才可通过name.coding.me登录 更改博客配置文件123456deploy: type: git repository: github: git@github.com:silencejql/silencejql.github.io.git coding: git@git.dev.tencent.com:silencejql/silencejql.coding.me.git branch: master 不同格式相应作出调整即可 可能出现的问题http://name.coding.me 在google chrome中打开可能会默认https，修复方式为: 地址栏中输入 chrome://net-internals/#hsts在 Delete domain security policies 中输入项目的域名，并 Delete 删除可以在 Query domain 测试是否删除成功 这里如果还是不行， 请清除浏览器缓存！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Coding</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[托管DLL与非托管DLL]]></title>
    <url>%2F2019%2F07%2F03%2F%E6%89%98%E7%AE%A1DLL%E4%B8%8E%E9%9D%9E%E6%89%98%E7%AE%A1DLL%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;托管DLL和非托管DLL的区别：狭义解释讲，托管DLL就在Dotnet环境生成的DLL文件；非托管DLL不是在Dotnet环境生成的DLL文件。&emsp;&emsp;托管DLL文件，可以在Dotnet环境通过 “添加引用” 的方式，直接把托管DLL文件添加到项目中，然后通过 Using DLL命名空间，来调用相应的DLL对象；非托管DLL文件，在Dotnet环境应用时，通过DllImport 调用。 概述&emsp;&emsp;托管dll虽然符合windows的PE格式规范，但是代码是以IL的形式保存在.Text 区的，而不是机器码，CLR会在运行时JIT编译成机器码再交给操作系统执行，这也就为什么托管代码称之为”托管”的意义。&emsp;&emsp;所以，要想注入托管dll，首先需要在目标进程中启动CLR，然后让CLR来加载managed dll。&emsp;&emsp;托管DLL，指完全由.NET托管代码实现的DLL，完全依赖于 .NET 平台的 CLR 运行。托管DLL，受.NET CLR管控，支持内存自动回收等的，对于.NET平台是安全DLL&emsp;&emsp;非托管DLL，是指完全或者部分 不是用.NET代码实现，不依赖于.NET平台即可运行，例如 COM方式 的DLL，不支持自动回收内存，对于.NET平台而言，也是非安全可控的。 &emsp;&emsp;正常编程所用的高级语言，是无法被计算机识别的。需要先将高级语言翻译为机器语言，才能被机器理解和运行。在标准C/C++中，编译过程是这样的：&emsp;&emsp;源代码首先经过预处理器，对头文件以及宏进行解析，然后经过编译器，生成汇编代码，接着，经过汇编，生成机器指令，最后将所有文件连接起来。这种编译方式的优点在于，最终直接生成了机器码，可以直接被计算机识别和运行，无需任何中间运行环境，但缺点也在于，由于不同平台能够识别的机器码不同，因此程序的跨平台能力较差。&emsp;&emsp;而在Java语言中，源代码并没有被直接翻译成机器码，而是编译成了一种中间代码（字节码Bytecode）。因此，运行Java程序需要一个额外的JRE（Java Runtime Enviromental）运行环境，在JRE中存在着JVM（Java Virtual Mechinal，Java虚拟机），在程序运行的时候，会将中间代码进一步解释为机器码，并在机器上运行。&emsp;&emsp;使用中间代码的好处在于，程序的跨平台性比较好，一次编译，可以在不同的设备上运行。&emsp;&emsp;托管/非托管是微软的.net framework中特有的概念，其中，非托管代码也叫本地（native）代码。与Java中的机制类似，也是先将源代码编译成中间代码（MSIL，Microsoft Intermediate Language），然后再由.net中的CLR将中间代码编译成机器代码。&emsp;&emsp;而C#与Java的区别在于，Java是先编译后解释，C#是两次编译。 调用DLL中的非托管函数一般方法首先，应该在C#语言源程序中声明外部方法，其基本形式是： [DLLImport(“DLL文件”)]修饰符 extern 返回变量类型 方法名称 （参数列表）其中： DLL文件：包含定义外部方法的库文件。修饰符： 访问修饰符，除了abstract以外在声明方法时可以使用的修饰符。返回变量类型：在DLL文件中你需调用方法的返回变量类型。方法名称：在DLL文件中你需调用方法的名称。参数列表：在DLL文件中你需调用方法的列表。 注意：需要在程序声明中使用System.Runtime.InteropServices命名空间。DllImport只能放置在方法声明上。DLL文件必须位于程序当前目录或系统定义的查询路径中（即：系统环境变量中Path所设置的路径）。返回变量类型、方法名称、参数列表一定要与DLL文件中的定义相一致。若要使用其它函数名，可以使用EntryPoint属性设置，如： 12345[DllImport("user32.dll", EntryPoint="MessageBoxA")]static extern int MsgBox(int hWnd, string msg, string caption, int type);[DllImportAttribute("CN210S_CSM_LV1.dll", EntryPoint = "uds_calc_key", CharSet = CharSet.Ansi)]private static extern void uds_calc_key_ldw(string seed, StringBuilder key); 其它可选的 DllImportAttribute 属性： CharSet： 指示用在入口点中的字符集，如：CharSet=CharSet.Ansi；SetLastError： 指示方法是否保留 Win32”上一错误”，如：SetLastError=true；ExactSpelling： 指示 EntryPoint 是否必须与指示的入口点的拼写完全匹配，如：ExactSpelling=false；PreserveSig： 指示方法的签名应当被保留还是被转换， 如：PreserveSig=true；CallingConvention： 指示入口点的调用约定， 如：CallingConvention=CallingConvention.Winapi；]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>托管DLL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[委托-匿名-Lambda表达式]]></title>
    <url>%2F2019%2F06%2F26%2F%E5%A7%94%E6%89%98-%E5%8C%BF%E5%90%8D-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[委托123456789101112131415161718192021222324252627282930313233delegate int calculator(int x, int y); //委托类型static void Main()&#123; calculator add = new calculator(Addition); int AddResult = add(1, 1); Console.Write(AddResult); calculator dec = new calculator(Subtraction); int SubResult = dec(2,1); Console.write(SubResult);&#125;/// &lt;summary&gt;/// 加法/// &lt;/summary&gt;/// &lt;param name="x"&gt;&lt;/param&gt;/// &lt;param name="y"&gt;&lt;/param&gt;/// &lt;returns&gt;x+y&lt;/returns&gt;public static int Addition(int x, int y)&#123; return x + y;&#125;/// &lt;summary&gt;/// 减法/// &lt;/summary&gt;/// &lt;param name="x"&gt;&lt;/param&gt;/// &lt;param name="y"&gt;&lt;/param&gt;/// &lt;returns&gt;x-y&lt;/returns&gt;public static int Subtraction(int x, int y)&#123; return x - y;&#125; 匿名方法12345678910111213141516delegate int calculator(int x, int y); //委托static void Main()&#123; calculator add = delegate(int num1,int num2) &#123; return num1 + num2; &#125;; calculator dec = delegate(int num1,int num2) &#123; return num1 - num2; &#125;; int AddResult = dec(1, 1); int SubResult = dec(2, 1); Console.Write(AddResult); Console.Write(SubResult);&#125; Lambda表达式1234567891011121314151617181920212223242526272829303132333435363738delegate bool MyBol(int x, int y);delegate bool MyBol_2(int x, string y);delegate int calculator(int x, int y); //委托类型delegate void VS();static void Main()&#123; MyBol Bol = (x, y) =&gt; x == y; MyBol_2 Bol_2 = (x, s) =&gt; s.Length &gt; x; calculator C = (X, Y) =&gt; X * Y; VS S = () =&gt; Console.Write("我是无参数Labada表达式"); int[] numbers = &#123; 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 &#125;; int oddNumbers = numbers.Count(n =&gt; n % 2 == 1); List&lt;People&gt; people = LoadData();//初始化 IEnumerable&lt;People&gt; results = people.Where(delegate(People p) &#123; return p.age &gt; 20; &#125;);&#125;private static List&lt;People&gt; LoadData()&#123; List&lt;People&gt; people = new List&lt;People&gt;(); //创建泛型对象 People p1 = new People(21, "guojing"); //创建一个对象 People p2 = new People(21, "wujunmin"); //创建一个对象 People p3 = new People(20, "muqing"); //创建一个对象 People p4 = new People(23, "lupan"); //创建一个对象 people.Add(p1); //添加一个对象 people.Add(p2); //添加一个对象 people.Add(p3); //添加一个对象 people.Add(p4); return people;&#125;public class People&#123; public int age &#123; get; set; &#125; //设置属性 public string name &#123; get; set; &#125; //设置属性 public People(int age, string name) //设置属性(构造函数构造) &#123; this.age = age; //初始化属性值age this.name = name; //初始化属性值name &#125;&#125; Func委托1234567891011121314//最后一个参数为返回值类型static void Main(string[] args)&#123; Func&lt;int, int, bool&gt; gwl = (p, j) =&gt; &#123; if (p + j == 10) &#123; return true; &#125; return false; &#125;; Console.WriteLine(gwl(5,5) + ""); //打印‘True’ Console.ReadKey();&#125;]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>委托</tag>
        <tag>匿名方法</tag>
        <tag>Lambda</tag>
        <tag>Func&lt;T&gt;委托</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Markdown]]></title>
    <url>%2F2019%2F06%2F15%2FHexo-Markdown%2F</url>
    <content type="text"><![CDATA[Hexo指令新建文章12345678$ hexo new 布局 &quot;文章名&quot;$ hexo clean //清除静态页面缓存（清除 public 文件夹) $ hexo g //在本地生成静态页面（生成 public 文件夹） $ hexo s //启动本地服务 http://localhost:4000，进行预览调试 $ hexo d //远程部署，同步到 GitHub $ npm install hexo-deployer-git --save //自动部署$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d //发布 Markdown格式首行缩进&amp;ensp; //相当于1个空格 &amp;emsp; //相当于2个空格，1个汉字 分段: 两个回车换行: 两个空格 + 回车标题: # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题 强调123*斜体* | **加粗** | ***斜体加粗*** _斜体_ | __加粗__ | ___斜体加粗___ ~~删除线~~ 引用: &gt; 注意后面紧跟个空格 123&gt; 以下为引用效果继续引用&gt; &gt;二级引用 以下为引用效果继续引用 二级引用 表格: - 和 | 分割行和列 ， : 控制对齐方式 12345| 0 | 1 | 2|| :- | -: | :-: || 0 | 1 | 2 || 0 | 1 | 2 || 0 | 1 | 2 | 0 1 2 0 1 2 0 1 2 0 1 2 代码块: 四个空格开头或三个` 链接: [文字](链接地址)图片: ![图片说明](图片地址)，地址可以是本地路径，也可以是网络地址列表: * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格 设置字体段落格式1234&lt;center&gt;居中&lt;/center&gt;&lt;font color=&quot;#FF0000&quot;&gt; 设置颜色 &lt;/font&gt; &lt;font size=6&gt; 设置大小 &lt;/font&gt;&lt;font size=5 color=&quot;#FF0000&quot;&gt; 设置颜色和大小&lt;/font&gt; 居中 设置颜色 设置大小 设置颜色和大小 引用站内文章在写文章的过程中，有时候需要引用站内的其他文章。可以通过内置的标签插件的语法post_link来实现引用。 Hexo主题设计头像头像配置文件位于：主题配置文件中的 avatar下 版权信息版权信息的配置文件位于：next\layout\_macro\my-copyright中 添加文章密码方法一(测试可用)安装hexo-blog-encrypt根目录的package.json文件夹中添加： 1&quot;hexo-blog-encrypt&quot;: &quot;2.0.*&quot; 然后在命令行输入： 1npm install 根目录下的_config.yml文件中添加： 123# Securityencrypt: enable: true 使用在需要加密的文章头部写入password： 123password: abc123abstract: Welcome to my blog, enter password to read.message: Welcome to my blog, enter password to read. 方法二在 themes-&gt;next-&gt;layout-&gt;\_partials-&gt;head.swig 中添加下面内容 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误,交钱还是跑路？'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章头部加入password。 添加边栏背景图在 themes\next\source\css\_custom\custom.styl文件中添加 12345678.sidebar &#123; background: url([https://ws2.sinaimg.cn/large/006tKfTcly1fq2wrm6g3cj309i0hq749.jpg](https://ws2.sinaimg.cn/large/006tKfTcly1fq2wrm6g3cj309i0hq749.jpg "https://ws2.sinaimg.cn/large/006tKfTcly1fq2wrm6g3cj309i0hq749.jpg")) no-repeat !important; background-size: cover !important; position: fixed !important; right: 0 !important; top: 0 !important; bottom: 0 !important;&#125; 网易云音乐插件主题文件夹 layout\_custom\sidebar.swig]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>主题</tag>
        <tag>文章密码</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碎碎念]]></title>
    <url>%2F2019%2F06%2F15%2F%E7%A2%8E%E7%A2%8E%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Enter password to read！ Incorrect Password! No content to display! U2FsdGVkX1+uSvylTATooipml+nrrXLGCyyCJamBA06cB/PdnuSrnysvbXoH5wzJ9G1SO9L7RxyhHjiqK0o50KgsjvBrVJlBvWOI8T5IjdlUIC7gcugCSJGMyXSlVxRrUSvL5Ipa/UViPJKtCppz0EpwpLRYB0ttg4MNFcetsfcszhIAfgVECn/9ZKQHAx6XnlnKg/6MDGYWqiVYtQNwnl0uuFTmQ+qffintSwoOVK8BIrO+Du8jAeL+OJ6O5yhycZ70IIJx48dAlqqLrDAEoc0YVUITe/9J0f2rrSOxav3rJ9pCc4gJw+I1z3F/2HxX0oPwOOd4W16GEkMgiPtmxkeORl5W/j0LoVWKZCdJ5apIIGUfLX5/PIvh9DmGPr+f2FPkLsYovZIYjdSxf/k/UYfLlzIkDjfCW9IPh7KbVeSJE7d7E6NeEzsGpeapVTNPqgUaE7N7Lx2TL1Y+CdKKyV/+TdNWjKJAuLW6bfMv1Qd2/KvdTd6kLej/uY4gdesCu+PqFjTeOoZqjGTyJD+2tJC0E6UfeDAquWVksmI1A499Tg55hwMG65giDyxE4oZao+JsfFwZAhVlooe1Ax6MZRfUYY/OG503HKBOnp0e6zWZO6zigWW/CxYFk5If+Fe8CDOo12QOGuwJx191FQ9RduRfFvX6hJhXqs3uwhxpwZ0tKRDvkUFwvnZNeR6ZkQmi]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test Project]]></title>
    <url>%2F2019%2F06%2F11%2FTest-Project%2F</url>
    <content type="text"><![CDATA[Test Filethis is my first Hexo text file]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
